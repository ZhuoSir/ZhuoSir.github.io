<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Phenix</title>

  
  <meta name="author" content="陈卓">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="Phenix"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Phenix" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Phenix</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2017/01/02/Java对象的创建过程/"><span>Java对象的创建过程</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/01/02/Java对象的创建过程/" rel="bookmark">
        <time class="entry-date published" datetime="2017-01-02T12:44:30.000Z">
          2017-01-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>Java程序执行的过程，如图：<br><img src="/images/classLoader.png" alt="Alt text"></p>
<h2 id="简要过程"><a href="#简要过程" class="headerlink" title="简要过程"></a>简要过程</h2><p>类加载完成后，主线程运行static main() 时在虚拟机中栈建栈，压栈  </p>
<p>执行new Object()时，在堆heap中创建对象。  </p>
<p>对象创建过程就是堆上分配实例对象内容空间的过程。在堆中对象内存空间的具体结构如下：<br><img src="/images/heap.png" alt="Alt text"></p>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>这个头包括两个部分，第一部分用于存储自身运行时的数据例如GC标志位、哈希码、锁状态等信息。第二部分存放指向方法区类静态数据的指针。  </p>
<h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3><p>存放类的属性数据信息，包括父类的属性信息。如果是数组的实例部分还包括数组的长度。这部分内存按4字节对齐。  </p>
<h3 id="填充数据"><a href="#填充数据" class="headerlink" title="填充数据"></a>填充数据</h3><p>这是因为虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。HotSpot VM的自动内存管理要求对象起始地址必须是8字节的整数倍。对象头本身是8的倍数，当对象的实例变量数据不是8的倍数，便需要填充数据来保证8字节的对齐。另外，堆上对象内存的分配是并发进行的.</p>
<p>然后执行类的构造函数初始化。  </p>
<p>Java虚拟机规范规定该区域可抛出OutOfMemoryError。  </p>
<h2 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h2><p>例如：</p>
<pre><code class="java">Dog dog = <span class="keyword">new</span> Dog();
</code></pre>
<p>当虚拟机执行到new指令时，它先在常量池中查找“Dog”，看能否定位到Dog类的符号引用；如果能，说明这个类已经被加载到方法区了，则继续执行。如果没有，就让Class Loader先执行类的加载。</p>
<p>然后，虚拟机开始为该对象分配内存，对象所需要的内存大小在类加载完成后就已经确定了。这时候只要在堆中按需求分配空间即可。具体分配内存时有两种方式，第一种，内存绝对规整，那么只要在被占用内存和空闲内存间放置指针即可，每次分配空间时只要把指针向空闲内存空间移动相应距离即可，当某对象被GC回收后，则需要进行某些对象内存的迁移。第二种，空闲内存和非空闲内存夹杂在一起，那么就需要用一个列表来记录堆内存的使用情况，然后按需分配内存。</p>
<p>对于多线程的情况，如何确保一个线程分配了对象内存但尚未修改内存管理指针时，其他线程又分配该块内存而覆盖的情况？有一种方法，就是让每一个线程在堆中先预分配一小块内存（TLAB本地线程分配缓冲），每个线程只在自己的内存中分配内存。但对象本身按其访问属性是可以线程共享访问的。</p>
<p>内存分配到后，虚拟机将分配的内存空间都初始化为零值(不包括对象头)。实例变量按变量类型初始化相应的默认值（数值型为0，boolan为false），所以实例变量不赋初值也能使用。接着设置对象头信息，比如对象的哈希值，GC分代年龄等。</p>
<p>从虚拟机角度，此时一个新的对象已经创建完成了。但从我们程序运行的角度，新建对象才刚刚开始，对象的构造方法还没有执行。只有执行完构造方法，按构造方法进行初始化后，对象才是彻底创建完成了。</p>
<p>构造函数的执行还涉及到调用父类构造器，如果没有显式声明调用父类构造器，则自动添加默认构造器。</p>
<p>到此，new运算符可以返回堆中这个对象的引用了。</p>
<p>此刻，会根据dog这个变量是实例变量、局部变量或静态变量的不同将引用放在不同的地方：</p>
<h3 id="如果dog局部变量，dog变量在栈帧的局部变量表，这个对象的引用就放在栈帧。"><a href="#如果dog局部变量，dog变量在栈帧的局部变量表，这个对象的引用就放在栈帧。" class="headerlink" title="如果dog局部变量，dog变量在栈帧的局部变量表，这个对象的引用就放在栈帧。"></a>如果dog局部变量，dog变量在栈帧的局部变量表，这个对象的引用就放在栈帧。</h3><h3 id="如果dog是实例变量，dog变量在堆中，对象的引用就放在堆。"><a href="#如果dog是实例变量，dog变量在堆中，对象的引用就放在堆。" class="headerlink" title="如果dog是实例变量，dog变量在堆中，对象的引用就放在堆。"></a>如果dog是实例变量，dog变量在堆中，对象的引用就放在堆。</h3><h3 id="如果dog是静态变量，dog变量在方法区，对象的引用就放在方法区。"><a href="#如果dog是静态变量，dog变量在方法区，对象的引用就放在方法区。" class="headerlink" title="如果dog是静态变量，dog变量在方法区，对象的引用就放在方法区。"></a>如果dog是静态变量，dog变量在方法区，对象的引用就放在方法区。</h3>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/Categories/Java/">Java</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/Tags/Java-对象/">Java,对象</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/12/25/Java内存基础知识/"><span>Java内存基础知识</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/12/25/Java内存基础知识/" rel="bookmark">
        <time class="entry-date published" datetime="2016-12-25T12:03:00.000Z">
          2016-12-25
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>Java内存分配中主要会涉及到一下几个区域：  </p>
<ul>
<li>寄存器：程序中无法控制</li>
<li>栈：存放基本类型的数据和对象引用，但对象本身不存放在栈中，而存放在堆中</li>
<li>堆：存放用<code>new</code>产生的数据</li>
<li>静态域：存放在对象中用<code>static</code>定义的静态成员</li>
<li>常量池：存放常量</li>
<li>非RAM存储：硬盘等永久存储空间  </li>
</ul>
<p>主要对堆，栈，常量池做简单描述。  </p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>在函数中定义的一些基本类型的变量数据和对象的引用变量都在函数的栈内存中分配。当在一段代码块中定义一个变量时，JAVA就在栈中分配此变量的内存空间，当该变量退出作用域的之后，JAVA的会自动释放掉为该变量所分配的内存空间（不是GC回收，而是主动释放，GC不处理栈）。</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆内存主要用来存放由<code>new</code>创建的对象或者数组。在堆中分配的内存，由JAVA的自动垃圾回收机制管理。在堆中产生数组或者对象<code>A</code>后，还可以在栈中定义一个引用变量<code>a</code>，这个引用变量<code>a</code>的值就是<code>A</code>在堆内存中的首地址。此引用变量<code>a</code>就是为<code>A</code>的起的一个名字。以后就可以直接使用栈中引用变量来访问堆中的数组或者对象。引用对象其实就是堆中对象的JAVA指针。<br>引用变量是个普通的变量，在栈中定义分配，在程序运行到其所在作用域范围之外后被释放。而在堆中所创建的对象或数组，即使程序运行到使用<code>new</code>的作用域之外，其本身也不会被释放。只有当其在没有任何引用变量指向它的时候，才会变为垃圾，不能被使用，然是仍然占据内存空间，在随后一个不确定的时间被GC回收并释放。这就是JAVA比较占内存的主要原因。  </p>
<h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>常量池是指在编译期被确定，并被保存在已编译的.class文件中的一些数据。除了包含代码中所定义的各种基本类型和对象型的常亮值（final）还包含一些以文本形式出现的符号引用，比如：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<p>JVM必须为每个被装载的类型维护一个常量池。常量池就是该类型所用到的常量的一个有序集合，包括直接常量和其他类型，字段和方法的符号引用。<br>对于<code>String</code>常量，它的值是在常量池中的。而JVM中的常量池在内存当中是以表的形式存在的， 对于<code>String</code>类型，有一张固定长度的<code>CONSTANT_String_info</code>表用来存储文字字符串值，注意：该表只存储文字字符串值，不存储符号引 用。说到这里，对常量池中的字符串值的存储位置应该有一个比较明了的理解了。<br>在程序执行的时候,常量池 会储存在<code>Method Area</code>,而不是堆中。<br>(未完待续。。。)</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/Categories/Java/">Java</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/Tags/Java-内存/">Java,内存</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/12/17/Java常用排序算法（二）/"><span>Java常用排序算法（二）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/12/17/Java常用排序算法（二）/" rel="bookmark">
        <time class="entry-date published" datetime="2016-12-17T12:14:00.000Z">
          2016-12-17
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序分很多种，这里主要说明直接插入排序，插入排序很适合已经排好序并且有其他元素要插入指定位置的的元素列。将整个元素列分为两部分。第一部分为被排序。第二部分为未排序。以升序为例，从未排序中取出一个元素，在被排序的元素序列中轮寻找，如果该元素（已排序）大于新元素（未排序中取出的元素），将该元素移到下一个位置。重复查找，直到已排序的元素小雨或等于新元素的位置，并将新元素插入到该位置中。再取出下一个元素，重复执行操作。最后得到的就是排好序的序列。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 插入排序&lt;br/&gt;</div><div class="line"> * &lt;ul&gt;</div><div class="line"> * &lt;li&gt;从第一个元素开始，该元素可以认为已经被排序&lt;/li&gt;</div><div class="line"> * &lt;li&gt;取出下一个元素，在已经排序的元素序列中从后向前扫描&lt;/li&gt;</div><div class="line"> * &lt;li&gt;如果该元素（已排序）大于新元素，将该元素移到下一位置&lt;/li&gt;</div><div class="line"> * &lt;li&gt;重复步骤3，直到找到已排序的元素小于或者等于新元素的位置&lt;/li&gt;</div><div class="line"> * &lt;li&gt;将新元素插入到该位置中&lt;/li&gt;</div><div class="line"> * &lt;li&gt;重复步骤2&lt;/li&gt;</div><div class="line"> * &lt;/ul&gt;</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> array</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSelect</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> length = array.length, temp, j;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</div><div class="line">        temp = array[i];</div><div class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; temp &lt; array[j - <span class="number">1</span>]; j--) &#123;</div><div class="line">            array[j] = array[j - <span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        array[j] = temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>插入排序属于稳定的排序算法。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>直接插入排序时间复杂度O(n^2)   </p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序属于较难理解的排序算法，是冯诺依曼发明的算法。该算法采用分治法的一种典型应用。整个算法分为两部分，递归分解（归），分别合并（并）。先将序列逐步分解分为多个单个元素的序列，然后再执行合并，合并操作较为复杂，合并的时候主要有两个序列，逐步比较两个数组，首先获取两个数组中较小的一个，知道某一个到达底部，再将另一个剩下的部分顺序取出。这样就获得一个排好序的新序列，在递归执行下一个序列合并操作。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 归并排序&lt;br/&gt;</div><div class="line"> * &lt;ul&gt;</div><div class="line"> * &lt;li&gt;申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列&lt;/li&gt;</div><div class="line"> * &lt;li&gt;设定两个指针，最初位置分别为两个已经排序序列的起始位置&lt;/li&gt;</div><div class="line"> * &lt;li&gt;比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置&lt;/li&gt;</div><div class="line"> * &lt;li&gt;重复步骤3直到某一指针达到序列尾&lt;/li&gt;</div><div class="line"> * &lt;li&gt;将另一序列剩下的所有元素直接复制到合并序列尾&lt;/li&gt;</div><div class="line"> * &lt;/ul&gt;</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> array</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;<span class="comment">// 每组元素个数</span></div><div class="line">    <span class="keyword">int</span> size = right - left + <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (t &lt; size) &#123;</div><div class="line">        <span class="keyword">int</span> s = t;<span class="comment">// 本次循环每组元素个数</span></div><div class="line">        t = <span class="number">2</span> * s;</div><div class="line">        <span class="keyword">int</span> i = left;</div><div class="line">        <span class="keyword">while</span> (i + (t - <span class="number">1</span>) &lt; size) &#123;</div><div class="line">            merge(array, i, i + (s - <span class="number">1</span>), i + (t - <span class="number">1</span>));</div><div class="line">            i += t;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (i + (s - <span class="number">1</span>) &lt; right)</div><div class="line">            merge(array, i, i + (s - <span class="number">1</span>), right);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 归并算法实现</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> array</div><div class="line"> * <span class="doctag">@param</span> low 低位</div><div class="line"> * <span class="doctag">@param</span> mid 中位</div><div class="line"> * <span class="doctag">@param</span> high 高位</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = low;</div><div class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span>[] tmpArray = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</div><div class="line">        <span class="keyword">if</span> (array[i] &lt;= array[j]) &#123;</div><div class="line">            tmpArray[k] = array[i];</div><div class="line">            i++;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            tmpArray[k] = array[j];</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line">        k++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</div><div class="line">        tmpArray[k] = array[i];</div><div class="line">        i++;</div><div class="line">        k++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (j &lt;= high) &#123;</div><div class="line">        tmpArray[k] = array[j];</div><div class="line">        j++;</div><div class="line">        k++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>, i = low; i &lt;= high; i++, k++) &#123;</div><div class="line">        array[i] = tmpArray[k];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>归并排序的时间复杂度为O(nlogn) </p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/Categories/Java/">Java</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/Tags/Java-排序/">Java,排序</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/12/17/Java常用排序算法/"><span>Java常用排序算法（一）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/12/17/Java常用排序算法/" rel="bookmark">
        <time class="entry-date published" datetime="2016-12-17T10:06:00.000Z">
          2016-12-17
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="冒泡法"><a href="#冒泡法" class="headerlink" title="冒泡法"></a>冒泡法</h2><p>冒泡排序相对于其他算法来讲较为简单，很好理解。以升序为例，主要是比较相邻的两个元素，如果第一个比第二个大就对换两个元素的位置。接下来比较下一对相邻的元素，对每一对相邻的元素做重复操作。一次轮寻之后就将元素中最大的元素排在了末尾，接下来比较其他元素（注意，第二次轮寻就没必要再比较最后一个元素了，因为他已经排好了）。继续轮寻重复比较，完成第二次轮寻之后就将第二大的元素排在了倒数第二的位置上，以此类推。重复执行元素个数的次数轮寻之后，得到的就是排好序的元素列。代码如下：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 冒泡法排序&lt;br/&gt;</div><div class="line"> * &lt;p&gt;</div><div class="line"> * &lt;li&gt;比较相邻的元素。如果第一个比第二个大，就交换他们两个。&lt;/li&gt;</div><div class="line"> * &lt;li&gt;对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。&lt;/li&gt;</div><div class="line"> * &lt;li&gt;针对所有的元素重复以上的步骤，除了最后一个。&lt;/li&gt;</div><div class="line"> * &lt;li&gt;持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。&lt;/li&gt;</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> array 需要排序的整型数组</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> temp;</div><div class="line">    <span class="keyword">int</span> endNum = array.length - <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; endNum; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (endNum) - i; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</div><div class="line">                temp = array[j];</div><div class="line">                array[j] = array[j + <span class="number">1</span>];</div><div class="line">                array[j + <span class="number">1</span>] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>冒泡排序是一种稳定排序算法。当两个元素相同时，无论是否相邻，都不会将两个元素兑换，没有这个必要，代码也没有这种实现。只有不同的时候，才会根据是升序还是降序而对调。冒泡排序较为简单，属于入门级别的排序算法。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>冒泡排序的最坏时间复杂度为O(n^2)，最好的时间复杂度O(n)，平均时间复杂度为O(n^2)。  </p>
<h2 id="快速排序法"><a href="#快速排序法" class="headerlink" title="快速排序法"></a>快速排序法</h2><p>快速排序法是对冒泡排序的一种改进。属于较难理解的排序算法。以升序为例，只需要一次轮寻排序，首先找到个基准点，一般是以首元素为基准点。将要排序的数组分为两部分，比基准点小的为一部分，排在基准点的左边；比基准点大的一部分，排在基准点的右边；然后按照此方法，在对两部分分别进行快速排序，整个排序过程可以递归进行。最后得到的数据就是有序数列。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 快速排序&lt;br/&gt;</div><div class="line"> * &lt;ul&gt;</div><div class="line"> * &lt;li&gt;从数列中挑出一个元素，称为“基准”&lt;/li&gt;</div><div class="line"> * &lt;li&gt;重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分割之后，</div><div class="line"> * 该基准是它的最后位置。这个称为分割（partition）操作。&lt;/li&gt;</div><div class="line"> * &lt;li&gt;递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。&lt;/li&gt;</div><div class="line"> * &lt;/ul&gt;</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> array</div><div class="line"> * <span class="doctag">@param</span> start</div><div class="line"> * <span class="doctag">@param</span> end</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (start &lt; end) &#123;</div><div class="line">        <span class="keyword">int</span> base = array[start];</div><div class="line">        <span class="keyword">int</span> temp;</div><div class="line">        <span class="keyword">int</span> i = start;</div><div class="line">        <span class="keyword">int</span> j = end;</div><div class="line"></div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            <span class="keyword">while</span> (array[i] &lt; base &amp;&amp; i &lt; end) &#123;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span> (array[j] &gt; base &amp;&amp; j &gt; start) &#123;</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (i &lt;= j) &#123;</div><div class="line">                temp = array[i];</div><div class="line">                array[i] = array[j];</div><div class="line">                array[j] = temp;</div><div class="line">                i++;</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">while</span> (i &lt;= j);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (start &lt; j) &#123;</div><div class="line">            quickSort(array, start, j);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (end &gt; i) &#123;</div><div class="line">            quickSort(array, i, end);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>快速排序还有很多改进版，比如随机选择基准数，或者在区间内数据较少时直接使用另外的排序算法，以降低递归深度。有兴趣可以继续研究。而且，这个算法在笔试中考的几率非常高，属于必须掌握的一种排序算法。</p>
<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>快速排序的时间复杂度为O(N*logN)  </p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序是一种很简单很直观的排序算法。以升序为例，从待排序的数组中选择出最小的，将他放在首位，再从剩余的数组元素中选择最小的，放在第二位，以此类推不断重复操作。最后的得到的就是排好序的数组。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 选择排序&lt;br/&gt;</div><div class="line"> * &lt;li&gt;在未排序序列中找到最小元素，存放到排序序列的起始位置&lt;/li&gt;</div><div class="line"> * &lt;li&gt;再从剩余未排序元素中继续寻找最小元素，然后放到排序序列第二位置。&lt;/li&gt;</div><div class="line"> * &lt;li&gt;以此类推，直到所有元素均排序完毕。&lt;/li&gt;</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> array</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> temp, length = array.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</div><div class="line">        <span class="keyword">int</span> k = i;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = length - <span class="number">1</span>; j &gt; i; j--) &#123;</div><div class="line">            <span class="keyword">if</span> (array[j] &lt; array[k]) &#123;</div><div class="line">                k = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        temp = array[k];</div><div class="line">        array[k] = array[i];</div><div class="line">        array[i] = temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>选择排序属于不稳定的排序算法。在一趟选择，如果一个元素比当前元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中两个5的相对前后顺序就被破坏了。</p>
<h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>选择排序的时间复杂度与冒泡排序的时间复杂度一样，同为O(n^2)  </p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/Categories/Java/">Java</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/Tags/Java-排序/">Java,排序</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/12/10/String，StringBuilder，StringBuffer性能比较/"><span>String，StringBuffer，StringBuilder性能比较</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/12/10/String，StringBuilder，StringBuffer性能比较/" rel="bookmark">
        <time class="entry-date published" datetime="2016-12-10T14:28:00.000Z">
          2016-12-10
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="一、HashCode比较"><a href="#一、HashCode比较" class="headerlink" title="一、HashCode比较"></a>一、HashCode比较</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先上段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      String str1 = <span class="string">"win this game"</span>;</div><div class="line">      System.out.println(<span class="string">"str1 的hashCode: "</span> + str1.hashCode());</div><div class="line"></div><div class="line">      str1 = str1 + <span class="string">" and next game"</span>;</div><div class="line">      System.out.println(<span class="string">"str1 的hashCode: "</span> + str1.hashCode());</div><div class="line"></div><div class="line">      StringBuffer sb1 = <span class="keyword">new</span> StringBuffer(<span class="string">"win this game"</span>);</div><div class="line">      System.out.println(<span class="string">"sb1 的hashCode: "</span> + sb1.hashCode());</div><div class="line">      System.out.println(<span class="string">"sb1 的string的hashCode: "</span> + sb1.toString().hashCode());</div><div class="line"></div><div class="line">      StringBuffer sb2 = sb1.append(<span class="string">" and next game"</span>);</div><div class="line">      System.out.println(<span class="string">"sb2 的hashCode: "</span> + sb2.hashCode());</div><div class="line">      sb2.insert(<span class="number">2</span>, <span class="string">"chen"</span>);</div><div class="line">      System.out.println(<span class="string">"sb2 的hashCode: "</span> + sb2.hashCode());</div><div class="line">      System.out.println(<span class="string">"sb2: "</span> + sb2.toString());</div><div class="line"></div><div class="line">      StringBuilder sbd1 = <span class="keyword">new</span> StringBuilder(<span class="string">"win this game"</span>);</div><div class="line">      System.out.println(<span class="string">"sbd1 的hashCode: "</span> + sbd1.hashCode());</div><div class="line">      sbd1.append(<span class="string">" and next game"</span>);</div><div class="line">      System.out.println(<span class="string">"sbd1 的hashCode: "</span> + sbd1.hashCode());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出：<br>str1 的hashCode: 1699949808<br>str1 的hashCode: -313455930<br>sb1 的hashCode: 1555009629<br>sb1 的string的hashCode: 1699949808<br>sb2 的hashCode: 1555009629<br>sb2 的hashCode: 1555009629<br>sb2: wichenn this game and next game<br>sbd1 的hashCode: 41359092<br>sbd1 的hashCode: 41359092</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用<code>System.out.println(obj.hashCode)</code>输出时对象的哈希码；而非内存地址。在java中是不可能获得对象的真正的内存地址的；因为java中堆是由JVM管理的不能直接操作；只能说此时打印出的hash码表示了该对象在java虚拟机中的内存地址；java虚拟机会根据该<code>hashCode</code>最终在真正的堆空间中给该对象分配一个地址；但是该地址不能通过java的API获取；<code>String</code>变量链接新的字符串时会改变<code>hashCode</code>，变量是在JVM中”链接–断开”；<code>StringBuffer</code> 变量链接新的字符串不会改变hashCode，因为变量的堆地址不会变；<code>StringBuilder</code> 变量链接新的字符串不会改变<code>hashCode</code>，因为变量的堆地址不会变；  </p>
<h3 id="二、性能比较"><a href="#二、性能比较" class="headerlink" title="二、性能比较"></a>二、性能比较</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</div><div class="line">        String str = <span class="string">""</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</div><div class="line">            str = str + <span class="string">"i"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">        <span class="keyword">long</span> time1 = end - begin;</div><div class="line">        System.out.println(<span class="string">"1. String + time = "</span> + time1);</div><div class="line"></div><div class="line">        <span class="keyword">long</span> begin2 = System.currentTimeMillis();</div><div class="line">        String str2 = <span class="string">""</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</div><div class="line">            str2 = str2.concat(i + <span class="string">""</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> end2 = System.currentTimeMillis();</div><div class="line">        <span class="keyword">long</span> time2 = end2 - begin2;</div><div class="line">        System.out.println(<span class="string">"2. String concat time = "</span> + time2);</div><div class="line"></div><div class="line">        <span class="keyword">long</span> begin3 = System.currentTimeMillis();</div><div class="line">        StringBuilder str3 = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</div><div class="line">            str3.append(<span class="string">""</span> + i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> end3 = System.currentTimeMillis();</div><div class="line">        <span class="keyword">long</span> time3 = end3 - begin3;</div><div class="line">        System.out.println(<span class="string">"3. StringBuilder append time = "</span> + time3);</div><div class="line"></div><div class="line">        <span class="keyword">long</span> begin4 = System.currentTimeMillis();</div><div class="line">        StringBuffer sf = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</div><div class="line">            sf.append(<span class="string">""</span> + i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> end4 = System.currentTimeMillis();</div><div class="line">        <span class="keyword">long</span> time4 = end4 - begin4;</div><div class="line">        System.out.println(<span class="string">"4. StringBuffer append time = "</span> + time4);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出：  </p>
<ol>
<li>String + time = 93</li>
<li>String concat time = 89</li>
<li>StringBuilder append time = 3</li>
<li>StringBuffer append time = 2</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>String</code>类由于java的共享设计，在修改变量时使其反复改变栈中的对于堆得引用地址，所以性能低；<code>StringBuffer</code> 和 <code>StringBuilder</code> 类设计时改变其值，其堆内存的地址不变，避免了反复修改栈引用的地址，其性能高；其中<code>StringBuilder</code> 是专门类似于<code>StringBuffer</code>类的非线性安全类，即<code>StringBuffer</code>是线性安全的，适合于多线程操作；<code>StringBuilder</code> 是线性不安全类，适合于单线程操作，其性能比<code>StringBuffer</code>略高;</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/Categories/Java/">Java</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/Tags/Java-String/">Java,String</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/12/06/Java反射练习（一）/"><span>Java反射练习（一）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/12/06/Java反射练习（一）/" rel="bookmark">
        <time class="entry-date published" datetime="2016-12-06T12:06:00.000Z">
          2016-12-06
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="反射基本API"><a href="#反射基本API" class="headerlink" title="反射基本API"></a>反射基本API</h1><h2 id="通过反射打印类的基本信息"><a href="#通过反射打印类的基本信息" class="headerlink" title="通过反射打印类的基本信息"></a>通过反射打印类的基本信息</h2><ol>
<li>获取基本的信息比如类名，不扯别的直接看代码：  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printDetail</span><span class="params">(DemoInterface demo)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"对象名："</span> + demo.getClass().getName());</div><div class="line">      System.out.println(<span class="string">"类型名："</span> + demo.getClass().getTypeName());</div><div class="line">      System.out.println(<span class="string">"规范名称："</span> + demo.getClass().getCanonicalName());</div><div class="line">      System.out.println(<span class="string">"所在包："</span> + demo.getClass().getPackage());</div><div class="line">      System.out.println(<span class="string">"简单名称："</span> + demo.getClass().getSimpleName());</div><div class="line">      List&lt;Class&lt;?&gt;&gt; interfaceList = Arrays.asList(demo.getClass().getInterfaces());</div><div class="line">      <span class="keyword">for</span> (Class&lt;?&gt; inter : interfaceList) &#123;</div><div class="line">          System.out.println(<span class="string">"实现了："</span> + inter.getName() + <span class="string">"接口"</span>);</div><div class="line">          Method[] methods = inter.getMethods();</div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</div><div class="line">              Method method = methods[i];</div><div class="line">              System.out.println(<span class="string">"方法："</span> + method.getName() + <span class="string">"；"</span>);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      Class&lt;?&gt; superClass = demo.getClass().getSuperclass();</div><div class="line">      System.out.println(<span class="string">"父类："</span> + superClass.getName());</div><div class="line">      Field[] fields = demo.getClass().getFields();</div><div class="line">      Field[] declaredFields = demo.getClass().getDeclaredFields();</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</div><div class="line">          fields[i].setAccessible(<span class="keyword">true</span>);</div><div class="line">          System.out.println(fields[i].getName());         <span class="comment">//public 公共可以访问的属性</span></div><div class="line">      &#125;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; declaredFields.length; i++) &#123;</div><div class="line">          System.out.println(declaredFields[i].getName()); <span class="comment">//private protected public属性，但是不包括继承属性</span></div><div class="line">      &#125;</div><div class="line">      Constructor&lt;?&gt; con[] = demo.getClass().getConstructors();</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; con.length; i++) &#123;</div><div class="line">          System.out.println(<span class="string">"构造函数："</span> + con[i]);</div><div class="line">      &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中几个函数有区别，<code>getField</code>是获取默认情况下可以访问到的属性，也就是公共属性<code>public</code>，如果要访问到私有属性<code>private</code>以及保护属性<code>protected</code>，调用<code>getDeclaredFields()</code>方法，但要注意，如果要对值进行修改，对每个field的访问性设为true,<code>field.setAccessible(true)</code>;  </p>
<ol>
<li>获取本类的全部属性，包括权限修饰符和属性类型，上代码：  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAllProperties</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">    Class&lt;?&gt; demo = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        demo = Class.forName(name);</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    System.out.println(<span class="string">"===============本类属性========================"</span>);</div><div class="line">    <span class="comment">// 取得本类的全部属性</span></div><div class="line">    Field[] field = demo.getDeclaredFields();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; field.length; i++) &#123;</div><div class="line">        <span class="comment">// 权限修饰符</span></div><div class="line">        <span class="keyword">int</span> mo = field[i].getModifiers();</div><div class="line">        String priv = Modifier.toString(mo);</div><div class="line">        <span class="comment">// 属性类型</span></div><div class="line">        Class&lt;?&gt; type = field[i].getType();</div><div class="line">        System.out.println(priv + <span class="string">" "</span> + type.getName() + <span class="string">" "</span></div><div class="line">                + field[i].getName() + <span class="string">";"</span>);</div><div class="line">    &#125;</div><div class="line">    System.out.println(<span class="string">"===============实现的接口或者父类，公共可访问的属性========================"</span>);</div><div class="line">    <span class="comment">// 取得实现的接口或者父类的属性</span></div><div class="line">    Field[] filed1 = demo.getFields();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; filed1.length; j++) &#123;</div><div class="line">        <span class="comment">// 权限修饰符</span></div><div class="line">        <span class="keyword">int</span> mo = filed1[j].getModifiers();</div><div class="line">        String priv = Modifier.toString(mo);</div><div class="line">        <span class="comment">// 属性类型</span></div><div class="line">        Class&lt;?&gt; type = filed1[j].getType();</div><div class="line">        System.out.println(priv + <span class="string">" "</span> + type.getName() + <span class="string">" "</span></div><div class="line">                + filed1[j].getName() + <span class="string">";"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>getModifier</code>为获取权限修饰符方法，比如<code>private,public,protected</code>；<code>getType</code>为获取属性的属性类型；  </p>
<h2 id="通过反射调用构造函数"><a href="#通过反射调用构造函数" class="headerlink" title="通过反射调用构造函数"></a>通过反射调用构造函数</h2><ol>
<li>构造函数的获取方式很简单，调用class.getConstructors()方法获取构造函数的数组；然后调用每个constructor的newInstance方法并传入相应的参数即可；上代码：  </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createObjByReflectConstructor</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">       Class&lt;?&gt; demo = <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           demo = Class.forName(name);</div><div class="line">       &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">           e.printStackTrace();</div><div class="line">       &#125;</div><div class="line">       DemoClass demoClass1 = <span class="keyword">null</span>;</div><div class="line">       DemoClass demoClass2 = <span class="keyword">null</span>;</div><div class="line">       DemoClass demoClass3 = <span class="keyword">null</span>;</div><div class="line">       DemoClass demoClass4 = <span class="keyword">null</span>;</div><div class="line">       DemoClass demoClass5 = <span class="keyword">null</span>;</div><div class="line">       Constructor&lt;?&gt; con[] = demo.getConstructors();</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           demoClass1 = (DemoClass) con[<span class="number">0</span>].newInstance();</div><div class="line">           demoClass2 = (DemoClass) con[<span class="number">1</span>].newInstance(<span class="number">1</span>);</div><div class="line">           demoClass4 = (DemoClass) con[<span class="number">2</span>].newInstance(<span class="number">2</span>, <span class="string">"wang"</span>);</div><div class="line">           demoClass3 = (DemoClass) con[<span class="number">3</span>].newInstance(<span class="string">"chen"</span>);</div><div class="line">           demoClass5 = (DemoClass) con[<span class="number">4</span>].newInstance(<span class="number">3</span>, <span class="string">"li"</span>, <span class="string">"win this game"</span>);</div><div class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">           e.printStackTrace();</div><div class="line">       &#125;</div><div class="line">       System.out.println(demoClass1);</div><div class="line">       System.out.println(demoClass2);</div><div class="line">       System.out.println(demoClass3);</div><div class="line">       System.out.println(demoClass4);</div><div class="line">       System.out.println(demoClass5);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>DemoClass</code>类有五个构造函数，所以返回了有五个元素的构造函数的数组，然后实例化。  </p>
<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取方法很简单。<code>class.getMethods()</code>就可以获取方法数组，如果想要获取指定函数，传入方法名：<code>class.getMethods(String methodName)</code>；上代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeMethod</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">      Class&lt;?&gt; demo = <span class="keyword">null</span>;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">          demo = Class.forName(name);</div><div class="line">      &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">          e.printStackTrace();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">          Method method = demo.getMethod(<span class="string">"sayHello"</span>);</div><div class="line">          method.invoke(demo.newInstance());</div><div class="line">          method = demo.getMethod(<span class="string">"add"</span>, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</div><div class="line">          <span class="keyword">double</span> result = (<span class="keyword">double</span>) method.invoke(demo.newInstance(), <span class="number">1</span>, <span class="number">2</span>);</div><div class="line">          System.out.println(<span class="string">"method 返回："</span> + result);</div><div class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">          e.printStackTrace();</div><div class="line">      &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先获取method，<code>demo.getMethod(&quot;add&quot;, int.class, int.class)</code>;,”add”是方法名，第二个和第三个参数是这个方法要传入的参数类型；调用函数，直接执行函数类的调用方法：<code>method.invoke()</code>；第一个参数是要执行此方法的类，注意要实例化；第二个参数和第三个参数就是方法执行所需要的实参；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实例代码链接：[代码] (<a href="https://github.com/ZhuoSir/SharpJava" target="_blank" rel="external">https://github.com/ZhuoSir/SharpJava</a>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天到此为止吧，不过反射的还会有后续的。。。。。。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/Categories/Java反射/">Java反射</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/Tags/Java-反射/">Java,反射</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/11/14/Servlet文件上传（fileupload开源方式）/"><span>Servlet文件上传</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/11/14/Servlet文件上传（fileupload开源方式）/" rel="bookmark">
        <time class="entry-date published" datetime="2016-11-14T14:10:00.000Z">
          2016-11-14
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="Servlet文件上传"><a href="#Servlet文件上传" class="headerlink" title="Servlet文件上传"></a>Servlet文件上传</h1><p>Servlet一般是在表单提交时候，通过Post请求将文件上传到服务器。上传的文件可以使任何文件，包括图片，文档等。这篇博客暂时只介绍通过Apache的开源包commons-fileupload的方式。首先导入两个必须的jar包：commons-fileupload，commons-io。我选用的版本是1.3.2和2.5。  </p>
<h2 id="文件上传表单"><a href="#文件上传表单" class="headerlink" title="文件上传表单"></a>文件上传表单</h2><p>注意:  </p>
<ul>
<li>表单提交的<code>method</code>方法必须是<code>post</code>,不能使用<code>get</code>方法。  </li>
<li>表单<code>enctype</code>的属性设置为<code>multipart/form-data</code>。</li>
<li>上传单个文件，您应该使用单个带有属性 <code>type=&quot;file&quot;</code> 的 <code>&lt;input .../&gt;</code>标签。为了允许多个文件上传，请包含多个 name 属性值不同的 input 标签。输入标签具有不同的名称属性的值。浏览器会为每个 input 标签关联一个浏览按钮。    </li>
</ul>
<pre><code><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"/TomcatTest/UploadServlet"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></div><div class="line">选择一个文件:</div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"uploadFile"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"上传"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure>
</code></pre><p>后端servlet</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@WebServlet</span>(name = <span class="string">"uploadServlet"</span>, urlPatterns = <span class="string">"/servlet/upload.do"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</div><div class="line">   	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionID = <span class="number">1L</span>;</div><div class="line">   	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String UPLOAD_DIRECTORY = <span class="string">"upload"</span>;</div><div class="line">   	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MEMORY_THRESHOLD = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">3</span>;  <span class="comment">// 3MB</span></div><div class="line">   	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_FILE_SIZE = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">40</span>; <span class="comment">// 40MB</span></div><div class="line">   	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_REQUEST_SIZE = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">50</span>; <span class="comment">// 50MB</span></div><div class="line"></div><div class="line">   	<span class="meta">@Override</span></div><div class="line">   	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></div><div class="line">           <span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line">       	doPost(req, resp);</div><div class="line">   	&#125;</div><div class="line"></div><div class="line">   	<span class="meta">@Override</span></div><div class="line">   	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></div><div class="line">   	        <span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line">   	    <span class="comment">//通过commons-fileupload包上传</span></div><div class="line">   	    uploadByCommonsJar(req, resp);</div><div class="line">   	    getServletContext().getRequestDispatcher(<span class="string">"/show.jsp"</span>)</div><div class="line">   	            .forward(req, resp);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">uploadByCommonsJar</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></div><div class="line">       	   	 <span class="keyword">throws</span> IOException &#123;</div><div class="line">       	<span class="keyword">if</span> (!ServletFileUpload.isMultipartContent(req)) &#123;                           <span class="comment">// 检测是否为多媒体上传</span></div><div class="line">           	PrintWriter writer = resp.getWriter();                                  <span class="comment">// 如果不是则停止</span></div><div class="line">           	writer.println(<span class="string">"Error: 表单必须包含 enctype=multipart/form-data"</span>);</div><div class="line">           	writer.flush();</div><div class="line">           	<span class="keyword">return</span>;</div><div class="line">       	&#125;</div><div class="line">       	DiskFileItemFactory factory = <span class="keyword">new</span> DiskFileItemFactory();</div><div class="line">       	factory.setSizeThreshold(MEMORY_THRESHOLD);                                 <span class="comment">// 设置内存临界值 - 超过后将产生临时文件并存储于临时目录中</span></div><div class="line">       	factory.setRepository(<span class="keyword">new</span> File(System.getProperty(<span class="string">"java.io.tmpdir"</span>)));      <span class="comment">// 设置临时存储目录</span></div><div class="line">       	ServletFileUpload upload = <span class="keyword">new</span> ServletFileUpload(factory);</div><div class="line">       	upload.setFileSizeMax(MAX_FILE_SIZE);                                       <span class="comment">// 设置最大文件上传值</span></div><div class="line">       	upload.setSizeMax(MAX_REQUEST_SIZE);                                        <span class="comment">// 设置最大请求值</span></div><div class="line">       	String uploadPath = getServletContext().getRealPath(<span class="string">"./"</span>)                   <span class="comment">// 获取上传路径</span></div><div class="line">          	     + File.separator + UPLOAD_DIRECTORY;</div><div class="line"></div><div class="line">      		File uploadDir = <span class="keyword">new</span> File(uploadPath);</div><div class="line">       	<span class="keyword">if</span> (!uploadDir.exists()) &#123;</div><div class="line">           	uploadDir.mkdirs();</div><div class="line">       	&#125;</div><div class="line"></div><div class="line">       	<span class="keyword">try</span> &#123;</div><div class="line">           	List&lt;FileItem&gt; fileItems = upload.parseRequest(req);                    <span class="comment">// 解析请求的内容提取文件数据</span></div><div class="line">           	<span class="keyword">if</span> (fileItems != <span class="keyword">null</span> &amp;&amp; !fileItems.isEmpty()) &#123;</div><div class="line">               	<span class="keyword">for</span> (FileItem item : fileItems) &#123;</div><div class="line">                   	String fileName = <span class="keyword">new</span> File(item.getName()).getName();</div><div class="line">                   	String filePath = uploadPath + File.separator + fileName;</div><div class="line">                   	File storeFile = <span class="keyword">new</span> File(filePath);</div><div class="line">                   	System.out.println(filePath);</div><div class="line">                   	item.write(storeFile);</div><div class="line">                   	req.setAttribute(<span class="string">"message"</span>, <span class="string">"文件上传成功"</span>);</div><div class="line">         	      	&#125;</div><div class="line">        	   	&#125;</div><div class="line">       	&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">     	      		e.printStackTrace();</div><div class="line">     	      		req.setAttribute(<span class="string">"message"</span>, e.getMessage());</div><div class="line">    	   	&#125;</div><div class="line">   	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>注意：我采用的是servlet3.0的注释方法配置。所以没有在web.xml里进行配置。接着在相应的show.jsp里显示上传成功的结果就可以了。show.jsp略。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/Categories/Servlet/">Servlet</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/Tags/文件上传/">文件上传</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/11/13/MarkDown-基本语法学习（第一篇）/"><span>MarkDown 基本语法学习（第一篇）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/11/13/MarkDown-基本语法学习（第一篇）/" rel="bookmark">
        <time class="entry-date published" datetime="2016-11-13T14:32:00.000Z">
          2016-11-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果一段文字被设为标题，只要在段首加上<code>#</code>就可以，例如：  </p>
<pre><code># 一级标题  
## 二级标题
### 三级标题
</code></pre><p>以此类推；</p>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;列表主要分为两种，有序和无序。  </p>
<h2 id="有序"><a href="#有序" class="headerlink" title="有序"></a>有序</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有序只要在前面加上数字即可，例如：  </p>
<pre><code>1. 你好
2. hello
3. 哦哈呦
</code></pre><h2 id="无序"><a href="#无序" class="headerlink" title="无序"></a>无序</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无序列表前面加上<code>*</code>符号就可以了。例如：  </p>
<pre><code>* 1
* 2
* 3
</code></pre><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在文中引用一处文字或者段落，可以在文本前面加上&gt;符号（大于号）。  </p>
<pre><code>&gt; 这里是引用。
</code></pre><p>效果如下</p>
<blockquote>
<p>这里是引用  </p>
</blockquote>
<h1 id="图片和链接"><a href="#图片和链接" class="headerlink" title="图片和链接"></a>图片和链接</h1><h2 id="图片格式"><a href="#图片格式" class="headerlink" title="图片格式"></a>图片格式</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;插入链接和图片的语法类似，区别在一个<code>!</code>号</p>
<pre><code>![](){ImgCap}{/ImgCap} //图片
[]() //链接  
</code></pre><p>例如：  </p>
<pre><code>[baidu]    (http://baidu.com)
![img](http://m2.quanjing.com/2m/fod_liv002/fo-11171537.jpg)
</code></pre><h1 id="粗体与斜体"><a href="#粗体与斜体" class="headerlink" title="粗体与斜体"></a>粗体与斜体</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;粗体和斜体的区别在于<em>符号的数量，粗体用两个 *</em> 号包裹，斜体只需要一个。  </p>
<pre><code>**粗体**
*斜体*
</code></pre><p>效果如下：<br><strong>粗体</strong><br><em>斜体</em></p>
<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表格比较麻烦，就用一个例子来说明吧，直接看例子就明白了。  </p>
<pre><code>| 姓名        | 年龄           | 性别  |
| ---------|:-------------:| -----:|
| 张三      | 22             | 男 |
| 李四      | 22                |   女 |
| 王二麻子   | 22            |    难 |
</code></pre><table>
<thead>
<tr>
<th>姓名</th>
<th style="text-align:center">年龄</th>
<th style="text-align:right">性别</th>
</tr>
</thead>
<tbody>
<tr>
<td>张三</td>
<td style="text-align:center">22</td>
<td style="text-align:right">男</td>
</tr>
<tr>
<td>李四</td>
<td style="text-align:center">22</td>
<td style="text-align:right">女</td>
</tr>
<tr>
<td>王二麻子</td>
<td style="text-align:center">22</td>
<td style="text-align:right">难</td>
</tr>
</tbody>
</table>
<p><code>:</code>符号代表对齐，居左代表左对齐，居右代表右对齐。左竖线一定要对齐。  </p>
<h1 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码框实现起来也很简单。只需要``将代码包裹起来就可以，这个符号一般在键盘ESC下面的那个按键。使用tab键可以进行缩进。  </p>
<h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><p>分割线的语法只需要三个<code>*</code>即可。例如：<code>***</code></p>
<hr>
<h1 id="其他常规"><a href="#其他常规" class="headerlink" title="其他常规"></a>其他常规</h1><p>markdown没有空格语法，一般就是<code>&amp;nbsp;</code>即可。如果想要换行，一般是<code>space + space + enter</code>;  </p>
<p>今天先写到这里吧。see U next time！</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/Categories/MarkDown学习/">MarkDown学习</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/Tags/MarkDown/">MarkDown</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/11/13/第一篇博客/"><span>第一篇博客</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/11/13/第一篇博客/" rel="bookmark">
        <time class="entry-date published" datetime="2016-11-13T04:17:28.000Z">
          2016-11-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>&nbsp;&nbsp;&nbsp;&nbsp;本人第一篇博客，以前一直想写，但是因为懒一直没有动笔。写博客的好处在于总结经验，加深记忆。但是我一直认为自己记忆力超出常人（事实也的确如此），所以很多乱七八糟的都存在脑子里，但是时间久了有个不好的地方，知识点太嘈杂。尤其是软件，必须要形成整个系统知识网络，所以开始写博客。<br>&nbsp;&nbsp;&nbsp;&nbsp;从今天开始，我会将自己的生活感受，工作上获取到的知识，尽量的写入博客里。开源分享，这是入门极客应该做的事儿。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/Tags/闲扯/">闲扯</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2017 陈卓
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>