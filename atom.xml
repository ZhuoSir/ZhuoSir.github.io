<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Phenix</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-02-20T15:46:22.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>陈卓</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库事务的四大特性以及事务的隔离级别</title>
    <link href="http://yoursite.com/2017/02/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%96%AF%E8%BE%BE%E7%89%B9%E6%80%A7%E4%BB%A5%E5%8F%8A%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://yoursite.com/2017/02/20/数据库事务的斯达特性以及事务的隔离级别/</id>
    <published>2017-02-20T15:40:00.000Z</published>
    <updated>2017-02-20T15:46:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇讲诉数据库中事务的四大特性（ACID），并且将会详细地说明事务的隔离级别。</p>
<p>如果一个数据库声称支持事务的操作，那么该数据库必须要具备以下四个特性：
　　</p>
<h3 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h3><p>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。  </p>
<h3 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h3><p>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p>
<p>拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。  </p>
<h3 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h3><p>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>
<p>即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p>
<h3 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h3><p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
<p>例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。<br>　　<br>　　<br>以上介绍完事务的四大特性(简称ACID)，现在重点来说明下事务的隔离性，当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，在介绍数据库提供的各种隔离级别之前，我们先看看如果不考虑事务的隔离性，会发生的几种问题：</p>
<h3 id="1-脏读"><a href="#1-脏读" class="headerlink" title="1 脏读"></a>1 脏读</h3><p>脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。</p>
<p>当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。例如：用户A向用户B转账100元，对应SQL命令如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> money=money+<span class="number">100</span> <span class="keyword">where</span> <span class="keyword">name</span>=’B’;  (此时A通知B)</div><div class="line"></div><div class="line">   <span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> money=money - <span class="number">100</span> <span class="keyword">where</span> <span class="keyword">name</span>=’A’;</div></pre></td></tr></table></figure>
<h3 id="2-不可重复读"><a href="#2-不可重复读" class="headerlink" title="2 不可重复读"></a>2 不可重复读</h3><p>不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</p>
<p>例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。</p>
<p>不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。</p>
<p>在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据A和B依次查询就可能不同，A和B就可能打起来了……</p>
<h3 id="3虚读-幻读"><a href="#3虚读-幻读" class="headerlink" title="3虚读(幻读)"></a>3虚读(幻读)</h3><p>幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</p>
<p>幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</p>
<p>　　现在来看看MySQL数据库为我们提供的四种隔离级别：</p>
<p>　　① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。</p>
<p>　　② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。</p>
<p>　　③ Read committed (读已提交)：可避免脏读的发生。</p>
<p>　　④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</p>
<p>以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，执行效率就越低。像Serializable这样的级别，就是以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。在MySQL数据库中默认的隔离级别为Repeatable read (可重复读)。</p>
<p>在MySQL数据库中，支持上面四种隔离级别，默认的为Repeatable read (可重复读)；而在Oracle数据库中，只支持Serializable (串行化)级别和Read committed (读已提交)这两种级别，其中默认的为Read committed级别。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇讲诉数据库中事务的四大特性（ACID），并且将会详细地说明事务的隔离级别。&lt;/p&gt;
&lt;p&gt;如果一个数据库声称支持事务的操作，那么该数据库必须要具备以下四个特性：
　　&lt;/p&gt;
&lt;h3 id=&quot;原子性（Atomicity）&quot;&gt;&lt;a href=&quot;#原子性（Atomicity
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/Categories/MySQL/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/Tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>使用HashMap代替大量if else判断</title>
    <link href="http://yoursite.com/2017/01/07/Java%E4%BD%BF%E7%94%A8HashMap%E4%BB%A3%E6%9B%BF%E5%A4%A7%E9%87%8F%20if%20else%20%E5%88%A4%E6%96%AD/"/>
    <id>http://yoursite.com/2017/01/07/Java使用HashMap代替大量 if else 判断/</id>
    <published>2017-01-07T10:58:00.000Z</published>
    <updated>2017-01-07T12:00:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>在业务比较复杂的开发过程中，经常会遇到一大堆的面向过程式的 if else 判断。不仅代码难看，而且效率也很低。所以如何运用面向对象的方法来代替这种写法，我找到一个很不错的办法。运用hashmap代替if else。比如以下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    String operate = <span class="string">"+"</span>;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">25</span>;</div><div class="line">    <span class="keyword">double</span> result = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (operate.equals(<span class="string">"+"</span>)) &#123;</div><div class="line">       result = a + b;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operate.equals(<span class="string">"-"</span>)) &#123;</div><div class="line">       result = a - b;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operate.equals(<span class="string">"*"</span>)) &#123;</div><div class="line">       result = a * b;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operate.equals(<span class="string">"/"</span>)) &#123;</div><div class="line">       result = a / b;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operate.equals(<span class="string">"%"</span>)) &#123;</div><div class="line">       result = a % b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    System.out.println(result);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运用HashMap + interface的方法代替，代码如下：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> HashMap&lt;String, calculate&gt; hashMap = <span class="keyword">new</span> HashMap&lt;String, calculate&gt;() &#123;</div><div class="line">    &#123;</div><div class="line">        put(<span class="string">"+"</span>, <span class="keyword">new</span> calculate() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> a + b;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        put(<span class="string">"-"</span>, <span class="keyword">new</span> calculate() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> a - b;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        put(<span class="string">"*"</span>, <span class="keyword">new</span> calculate() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> a * b;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        put(<span class="string">"/"</span>, <span class="keyword">new</span> calculate() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> a / b;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        put(<span class="string">"%"</span>, <span class="keyword">new</span> calculate() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> a % b;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    String operate = <span class="string">"*"</span>;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">25</span>;</div><div class="line">    <span class="keyword">float</span> result = <span class="number">0</span>;</div><div class="line"></div><div class="line">    calculate cal = hashMap.get(operate);</div><div class="line">    <span class="keyword">if</span> (cal != <span class="keyword">null</span>) &#123;</div><div class="line">        result = cal.calculate(a, b);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    System.out.println(result);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，使用HashMap的方法，主体代码更加的简洁，而且判断过程交给了hash算法来进行匹配，效率更高。并且在定义hashMap过程中，可以很清晰的看到每种可能将会执行的业务方法。在主题函数中，只需要判断这种情况存不存在，如果存在，执行方法就可以了。  </p>
<p>当然也可以使用反射的方法调用函数。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;() &#123;</div><div class="line"></div><div class="line">        &#123;</div><div class="line">            put(<span class="string">"+"</span>, <span class="string">"add"</span>);</div><div class="line">            put(<span class="string">"-"</span>, <span class="string">"subtract"</span>);</div><div class="line">            put(<span class="string">"*"</span>, <span class="string">"multiply"</span>);</div><div class="line">            put(<span class="string">"/"</span>, <span class="string">"except"</span>);</div><div class="line">            put(<span class="string">"%"</span>, <span class="string">"over"</span>);</div><div class="line">        &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"></div><div class="line">	String operate = <span class="string">"+"</span>;</div><div class="line">        <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">25</span>;</div><div class="line">        <span class="keyword">double</span> result = <span class="number">0</span>;</div><div class="line"></div><div class="line">        String methodName = hashMap.get(operate);</div><div class="line">        <span class="keyword">if</span> (methodName != <span class="keyword">null</span>) &#123;</div><div class="line">            Class&lt;?&gt; java = Class.forName(JavaTest2.class.getName());</div><div class="line">            Method method = java.getMethod(methodName, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</div><div class="line">            result = (<span class="keyword">double</span>) method.invoke(java.newInstance(), a, b);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println(result);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种写法，比HashMap + interface的更加简单，毕竟不用定义interface了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在业务比较复杂的开发过程中，经常会遇到一大堆的面向过程式的 if else 判断。不仅代码难看，而且效率也很低。所以如何运用面向对象的方法来代替这种写法，我找到一个很不错的办法。运用hashmap代替if else。比如以下代码：&lt;br&gt;&lt;figure class=&quot;hig
    
    </summary>
    
      <category term="HashMap" scheme="http://yoursite.com/Categories/HashMap/"/>
    
    
      <category term="if else" scheme="http://yoursite.com/Tags/if-else/"/>
    
  </entry>
  
  <entry>
    <title>常用的正则表达式</title>
    <link href="http://yoursite.com/2017/01/07/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/01/07/常用的正则表达式/</id>
    <published>2017-01-07T10:38:00.000Z</published>
    <updated>2017-01-07T10:54:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="校验密码强度"><a href="#校验密码强度" class="headerlink" title="校验密码强度"></a>校验密码强度</h3><p>密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$</div></pre></td></tr></table></figure></p>
<h3 id="校验中文"><a href="#校验中文" class="headerlink" title="校验中文"></a>校验中文</h3><p>字符串仅能是中文<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">^[\\u4e00-\\u9fa5]&#123;0,&#125;$</div></pre></td></tr></table></figure></p>
<h3 id="由数字、26个英文字母或下划线组成的字符串"><a href="#由数字、26个英文字母或下划线组成的字符串" class="headerlink" title="由数字、26个英文字母或下划线组成的字符串"></a>由数字、26个英文字母或下划线组成的字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">^\\w+$</div></pre></td></tr></table></figure>
<h3 id="校验E-Mail-地址"><a href="#校验E-Mail-地址" class="headerlink" title="校验E-Mail 地址"></a>校验E-Mail 地址</h3><p>同密码一样，下面是E-mail地址合规性的正则检查语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[\\w!#$%&amp;&apos;*+/=?^_`&#123;|&#125;~-]+(?:\\.[\\w!#$%&amp;&apos;*+/=?^_`&#123;|&#125;~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])?</div></pre></td></tr></table></figure></p>
<h3 id="校验身份证号码"><a href="#校验身份证号码" class="headerlink" title="校验身份证号码"></a>校验身份证号码</h3><p>下面是身份证号码的正则校验。15 或 18位。 </p>
<p>15位：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">^[1-9]\\d&#123;7&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;$</div></pre></td></tr></table></figure></p>
<p>18位：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">^[1-9]\\d&#123;5&#125;[1-9]\\d&#123;3&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;([0-9]|X)$</div></pre></td></tr></table></figure></p>
<h3 id="校验日期"><a href="#校验日期" class="headerlink" title="校验日期"></a>校验日期</h3><p>“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">^(?:(?!0000)[0-9]&#123;4&#125;-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$</div></pre></td></tr></table></figure>
<h3 id="校验金额"><a href="#校验金额" class="headerlink" title="校验金额"></a>校验金额</h3><p>金额校验，精确到2位小数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">^[0-9]+(.[0-9]&#123;2&#125;)?$</div></pre></td></tr></table></figure>
<h3 id="校验手机号"><a href="#校验手机号" class="headerlink" title="校验手机号"></a>校验手机号</h3><p>下面是国内 13、15、18开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d&#123;8&#125;$</div></pre></td></tr></table></figure>
<h3 id="判断IE的版本"><a href="#判断IE的版本" class="headerlink" title="判断IE的版本"></a>判断IE的版本</h3><p>IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">^.*MSIE [5-8](?:\\.[0-9]+)?(?!.*Trident\\/[5-9]\\.0).*$</div></pre></td></tr></table></figure>
<h3 id="校验IP-v4地址"><a href="#校验IP-v4地址" class="headerlink" title="校验IP-v4地址"></a>校验IP-v4地址</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b</div></pre></td></tr></table></figure>
<h3 id="校验IP-v6地址"><a href="#校验IP-v6地址" class="headerlink" title="校验IP-v6地址"></a>校验IP-v6地址</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(([0-9a-fA-F]&#123;1,4&#125;:)&#123;7,7&#125;[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,7&#125;:|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,6&#125;:[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,5&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,2&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,3&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,3&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,2&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,5&#125;|[0-9a-fA-F]&#123;1,4&#125;:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,6&#125;)|:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,7&#125;|:)|fe80:(:[0-9a-fA-F]&#123;0,4&#125;)&#123;0,4&#125;%[0-9a-zA-Z]&#123;1,&#125;|::(ffff(:0&#123;1,4&#125;)&#123;0,1&#125;:)&#123;0,1&#125;((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;:((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9]))</div></pre></td></tr></table></figure>
<h3 id="检查URL的前缀"><a href="#检查URL的前缀" class="headerlink" title="检查URL的前缀"></a>检查URL的前缀</h3><p>应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!s.match(/^[a-zA-Z]+:\\/\\<span class="comment">//)) </span></div><div class="line">&#123; </div><div class="line">    s = <span class="string">'http://'</span> + s; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="提取URL链接"><a href="#提取URL链接" class="headerlink" title="提取URL链接"></a>提取URL链接</h3><p>下面的这个表达式可以筛选出一段文本中的URL。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">^(f|ht)&#123;1&#125;(tp|tps):\\/\\/([\\w-]+\\.)+[\\w-]+(\\/[\\w- ./?%&amp;=]*)?</div></pre></td></tr></table></figure>
<h3 id="文件路径及扩展名校验"><a href="#文件路径及扩展名校验" class="headerlink" title="文件路径及扩展名校验"></a>文件路径及扩展名校验</h3><p>验证windows下文件路径和扩展名（下面的例子中为.txt文件）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?&quot;&lt;&gt;|]+\\.txt(l)?$</div></pre></td></tr></table></figure>
<h3 id="提取Color-Hex-Codes"><a href="#提取Color-Hex-Codes" class="headerlink" title="提取Color Hex Codes"></a>提取Color Hex Codes</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">^#([A-Fa-f0-9]&#123;6&#125;|[A-Fa-f0-9]&#123;3&#125;)$</div></pre></td></tr></table></figure>
<h3 id="提取网页图片"><a href="#提取网页图片" class="headerlink" title="提取网页图片"></a>提取网页图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">\\&lt; *[img][^\\\\&gt;]*[src] *= *[\\&quot;\\&apos;]&#123;0,1&#125;([^\\&quot;\\&apos;\\ &gt;]*)</div></pre></td></tr></table></figure>
<h3 id="提取页面超链接"><a href="#提取页面超链接" class="headerlink" title="提取页面超链接"></a>提取页面超链接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(&lt;a\\s*(?!.*\\brel=)[^&gt;]*)(href=&quot;https?:\\/\\/)((?!(?:(?:www\\.)?&apos;.implode(&apos;|(?:www\\.)?&apos;, $follow_list).&apos;))[^&quot;]+)&quot;((?!.*\\brel=)[^&gt;]*)(?:[^&gt;]*)&gt;</div></pre></td></tr></table></figure>
<h3 id="匹配HTML标签"><a href="#匹配HTML标签" class="headerlink" title="匹配HTML标签"></a>匹配HTML标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;\\/?\\w+((\\s+\\w+(\\s*=\\s*(?:&quot;.*?&quot;|&apos;.*?&apos;|[\\^&apos;&quot;&gt;\\s]+))?)+\\s*|\\s*)\\/?&gt;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;校验密码强度&quot;&gt;&lt;a href=&quot;#校验密码强度&quot; class=&quot;headerlink&quot; title=&quot;校验密码强度&quot;&gt;&lt;/a&gt;校验密码强度&lt;/h3&gt;&lt;p&gt;密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。&lt;br&gt;&lt;figure c
    
    </summary>
    
      <category term="正则表达式" scheme="http://yoursite.com/Categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    
      <category term="正则表达式" scheme="http://yoursite.com/Tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java对象的创建过程</title>
    <link href="http://yoursite.com/2017/01/02/Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/01/02/Java对象的创建过程/</id>
    <published>2017-01-02T12:44:30.000Z</published>
    <updated>2017-01-02T13:12:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java程序执行的过程，如图：<br><img src="/images/classLoader.png" alt="Alt text"></p>
<h2 id="简要过程"><a href="#简要过程" class="headerlink" title="简要过程"></a>简要过程</h2><p>类加载完成后，主线程运行static main() 时在虚拟机中栈建栈，压栈  </p>
<p>执行new Object()时，在堆heap中创建对象。  </p>
<p>对象创建过程就是堆上分配实例对象内容空间的过程。在堆中对象内存空间的具体结构如下：<br><img src="/images/heap.png" alt="Alt text"></p>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>这个头包括两个部分，第一部分用于存储自身运行时的数据例如GC标志位、哈希码、锁状态等信息。第二部分存放指向方法区类静态数据的指针。  </p>
<h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3><p>存放类的属性数据信息，包括父类的属性信息。如果是数组的实例部分还包括数组的长度。这部分内存按4字节对齐。  </p>
<h3 id="填充数据"><a href="#填充数据" class="headerlink" title="填充数据"></a>填充数据</h3><p>这是因为虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。HotSpot VM的自动内存管理要求对象起始地址必须是8字节的整数倍。对象头本身是8的倍数，当对象的实例变量数据不是8的倍数，便需要填充数据来保证8字节的对齐。另外，堆上对象内存的分配是并发进行的.</p>
<p>然后执行类的构造函数初始化。  </p>
<p>Java虚拟机规范规定该区域可抛出OutOfMemoryError。  </p>
<h2 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h2><p>例如：</p>
<pre><code class="java">Dog dog = <span class="keyword">new</span> Dog();
</code></pre>
<p>当虚拟机执行到new指令时，它先在常量池中查找“Dog”，看能否定位到Dog类的符号引用；如果能，说明这个类已经被加载到方法区了，则继续执行。如果没有，就让Class Loader先执行类的加载。</p>
<p>然后，虚拟机开始为该对象分配内存，对象所需要的内存大小在类加载完成后就已经确定了。这时候只要在堆中按需求分配空间即可。具体分配内存时有两种方式，第一种，内存绝对规整，那么只要在被占用内存和空闲内存间放置指针即可，每次分配空间时只要把指针向空闲内存空间移动相应距离即可，当某对象被GC回收后，则需要进行某些对象内存的迁移。第二种，空闲内存和非空闲内存夹杂在一起，那么就需要用一个列表来记录堆内存的使用情况，然后按需分配内存。</p>
<p>对于多线程的情况，如何确保一个线程分配了对象内存但尚未修改内存管理指针时，其他线程又分配该块内存而覆盖的情况？有一种方法，就是让每一个线程在堆中先预分配一小块内存（TLAB本地线程分配缓冲），每个线程只在自己的内存中分配内存。但对象本身按其访问属性是可以线程共享访问的。</p>
<p>内存分配到后，虚拟机将分配的内存空间都初始化为零值(不包括对象头)。实例变量按变量类型初始化相应的默认值（数值型为0，boolan为false），所以实例变量不赋初值也能使用。接着设置对象头信息，比如对象的哈希值，GC分代年龄等。</p>
<p>从虚拟机角度，此时一个新的对象已经创建完成了。但从我们程序运行的角度，新建对象才刚刚开始，对象的构造方法还没有执行。只有执行完构造方法，按构造方法进行初始化后，对象才是彻底创建完成了。</p>
<p>构造函数的执行还涉及到调用父类构造器，如果没有显式声明调用父类构造器，则自动添加默认构造器。</p>
<p>到此，new运算符可以返回堆中这个对象的引用了。</p>
<p>此刻，会根据dog这个变量是实例变量、局部变量或静态变量的不同将引用放在不同的地方：</p>
<h3 id="如果dog局部变量，dog变量在栈帧的局部变量表，这个对象的引用就放在栈帧。"><a href="#如果dog局部变量，dog变量在栈帧的局部变量表，这个对象的引用就放在栈帧。" class="headerlink" title="如果dog局部变量，dog变量在栈帧的局部变量表，这个对象的引用就放在栈帧。"></a>如果dog局部变量，dog变量在栈帧的局部变量表，这个对象的引用就放在栈帧。</h3><h3 id="如果dog是实例变量，dog变量在堆中，对象的引用就放在堆。"><a href="#如果dog是实例变量，dog变量在堆中，对象的引用就放在堆。" class="headerlink" title="如果dog是实例变量，dog变量在堆中，对象的引用就放在堆。"></a>如果dog是实例变量，dog变量在堆中，对象的引用就放在堆。</h3><h3 id="如果dog是静态变量，dog变量在方法区，对象的引用就放在方法区。"><a href="#如果dog是静态变量，dog变量在方法区，对象的引用就放在方法区。" class="headerlink" title="如果dog是静态变量，dog变量在方法区，对象的引用就放在方法区。"></a>如果dog是静态变量，dog变量在方法区，对象的引用就放在方法区。</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java程序执行的过程，如图：&lt;br&gt;&lt;img src=&quot;/images/classLoader.png&quot; alt=&quot;Alt text&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;简要过程&quot;&gt;&lt;a href=&quot;#简要过程&quot; class=&quot;headerlink&quot; title=&quot;简要过程&quot;&gt;&lt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/Categories/Java/"/>
    
    
      <category term="Java,对象" scheme="http://yoursite.com/Tags/Java-%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java内存基础知识</title>
    <link href="http://yoursite.com/2016/12/25/Java%E5%86%85%E5%AD%98%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2016/12/25/Java内存基础知识/</id>
    <published>2016-12-25T12:03:00.000Z</published>
    <updated>2016-12-25T12:49:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java内存分配中主要会涉及到一下几个区域：  </p>
<ul>
<li>寄存器：程序中无法控制</li>
<li>栈：存放基本类型的数据和对象引用，但对象本身不存放在栈中，而存放在堆中</li>
<li>堆：存放用<code>new</code>产生的数据</li>
<li>静态域：存放在对象中用<code>static</code>定义的静态成员</li>
<li>常量池：存放常量</li>
<li>非RAM存储：硬盘等永久存储空间  </li>
</ul>
<p>主要对堆，栈，常量池做简单描述。  </p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>在函数中定义的一些基本类型的变量数据和对象的引用变量都在函数的栈内存中分配。当在一段代码块中定义一个变量时，JAVA就在栈中分配此变量的内存空间，当该变量退出作用域的之后，JAVA的会自动释放掉为该变量所分配的内存空间（不是GC回收，而是主动释放，GC不处理栈）。</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆内存主要用来存放由<code>new</code>创建的对象或者数组。在堆中分配的内存，由JAVA的自动垃圾回收机制管理。在堆中产生数组或者对象<code>A</code>后，还可以在栈中定义一个引用变量<code>a</code>，这个引用变量<code>a</code>的值就是<code>A</code>在堆内存中的首地址。此引用变量<code>a</code>就是为<code>A</code>的起的一个名字。以后就可以直接使用栈中引用变量来访问堆中的数组或者对象。引用对象其实就是堆中对象的JAVA指针。<br>引用变量是个普通的变量，在栈中定义分配，在程序运行到其所在作用域范围之外后被释放。而在堆中所创建的对象或数组，即使程序运行到使用<code>new</code>的作用域之外，其本身也不会被释放。只有当其在没有任何引用变量指向它的时候，才会变为垃圾，不能被使用，然是仍然占据内存空间，在随后一个不确定的时间被GC回收并释放。这就是JAVA比较占内存的主要原因。  </p>
<h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>常量池是指在编译期被确定，并被保存在已编译的.class文件中的一些数据。除了包含代码中所定义的各种基本类型和对象型的常亮值（final）还包含一些以文本形式出现的符号引用，比如：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<p>JVM必须为每个被装载的类型维护一个常量池。常量池就是该类型所用到的常量的一个有序集合，包括直接常量和其他类型，字段和方法的符号引用。<br>对于<code>String</code>常量，它的值是在常量池中的。而JVM中的常量池在内存当中是以表的形式存在的， 对于<code>String</code>类型，有一张固定长度的<code>CONSTANT_String_info</code>表用来存储文字字符串值，注意：该表只存储文字字符串值，不存储符号引 用。说到这里，对常量池中的字符串值的存储位置应该有一个比较明了的理解了。<br>在程序执行的时候,常量池 会储存在<code>Method Area</code>,而不是堆中。<br>(未完待续。。。)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java内存分配中主要会涉及到一下几个区域：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;寄存器：程序中无法控制&lt;/li&gt;
&lt;li&gt;栈：存放基本类型的数据和对象引用，但对象本身不存放在栈中，而存放在堆中&lt;/li&gt;
&lt;li&gt;堆：存放用&lt;code&gt;new&lt;/code&gt;产生的数据&lt;/li&gt;
&lt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/Categories/Java/"/>
    
    
      <category term="Java,内存" scheme="http://yoursite.com/Tags/Java-%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Java常用排序算法（二）</title>
    <link href="http://yoursite.com/2016/12/17/Java%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2016/12/17/Java常用排序算法（二）/</id>
    <published>2016-12-17T12:14:00.000Z</published>
    <updated>2016-12-17T12:31:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序分很多种，这里主要说明直接插入排序，插入排序很适合已经排好序并且有其他元素要插入指定位置的的元素列。将整个元素列分为两部分。第一部分为被排序。第二部分为未排序。以升序为例，从未排序中取出一个元素，在被排序的元素序列中轮寻找，如果该元素（已排序）大于新元素（未排序中取出的元素），将该元素移到下一个位置。重复查找，直到已排序的元素小雨或等于新元素的位置，并将新元素插入到该位置中。再取出下一个元素，重复执行操作。最后得到的就是排好序的序列。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 插入排序&lt;br/&gt;</div><div class="line"> * &lt;ul&gt;</div><div class="line"> * &lt;li&gt;从第一个元素开始，该元素可以认为已经被排序&lt;/li&gt;</div><div class="line"> * &lt;li&gt;取出下一个元素，在已经排序的元素序列中从后向前扫描&lt;/li&gt;</div><div class="line"> * &lt;li&gt;如果该元素（已排序）大于新元素，将该元素移到下一位置&lt;/li&gt;</div><div class="line"> * &lt;li&gt;重复步骤3，直到找到已排序的元素小于或者等于新元素的位置&lt;/li&gt;</div><div class="line"> * &lt;li&gt;将新元素插入到该位置中&lt;/li&gt;</div><div class="line"> * &lt;li&gt;重复步骤2&lt;/li&gt;</div><div class="line"> * &lt;/ul&gt;</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> array</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSelect</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> length = array.length, temp, j;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</div><div class="line">        temp = array[i];</div><div class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; temp &lt; array[j - <span class="number">1</span>]; j--) &#123;</div><div class="line">            array[j] = array[j - <span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        array[j] = temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>插入排序属于稳定的排序算法。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>直接插入排序时间复杂度O(n^2)   </p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序属于较难理解的排序算法，是冯诺依曼发明的算法。该算法采用分治法的一种典型应用。整个算法分为两部分，递归分解（归），分别合并（并）。先将序列逐步分解分为多个单个元素的序列，然后再执行合并，合并操作较为复杂，合并的时候主要有两个序列，逐步比较两个数组，首先获取两个数组中较小的一个，知道某一个到达底部，再将另一个剩下的部分顺序取出。这样就获得一个排好序的新序列，在递归执行下一个序列合并操作。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 归并排序&lt;br/&gt;</div><div class="line"> * &lt;ul&gt;</div><div class="line"> * &lt;li&gt;申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列&lt;/li&gt;</div><div class="line"> * &lt;li&gt;设定两个指针，最初位置分别为两个已经排序序列的起始位置&lt;/li&gt;</div><div class="line"> * &lt;li&gt;比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置&lt;/li&gt;</div><div class="line"> * &lt;li&gt;重复步骤3直到某一指针达到序列尾&lt;/li&gt;</div><div class="line"> * &lt;li&gt;将另一序列剩下的所有元素直接复制到合并序列尾&lt;/li&gt;</div><div class="line"> * &lt;/ul&gt;</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> array</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;<span class="comment">// 每组元素个数</span></div><div class="line">    <span class="keyword">int</span> size = right - left + <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (t &lt; size) &#123;</div><div class="line">        <span class="keyword">int</span> s = t;<span class="comment">// 本次循环每组元素个数</span></div><div class="line">        t = <span class="number">2</span> * s;</div><div class="line">        <span class="keyword">int</span> i = left;</div><div class="line">        <span class="keyword">while</span> (i + (t - <span class="number">1</span>) &lt; size) &#123;</div><div class="line">            merge(array, i, i + (s - <span class="number">1</span>), i + (t - <span class="number">1</span>));</div><div class="line">            i += t;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (i + (s - <span class="number">1</span>) &lt; right)</div><div class="line">            merge(array, i, i + (s - <span class="number">1</span>), right);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 归并算法实现</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> array</div><div class="line"> * <span class="doctag">@param</span> low 低位</div><div class="line"> * <span class="doctag">@param</span> mid 中位</div><div class="line"> * <span class="doctag">@param</span> high 高位</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = low;</div><div class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span>[] tmpArray = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</div><div class="line">        <span class="keyword">if</span> (array[i] &lt;= array[j]) &#123;</div><div class="line">            tmpArray[k] = array[i];</div><div class="line">            i++;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            tmpArray[k] = array[j];</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line">        k++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</div><div class="line">        tmpArray[k] = array[i];</div><div class="line">        i++;</div><div class="line">        k++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (j &lt;= high) &#123;</div><div class="line">        tmpArray[k] = array[j];</div><div class="line">        j++;</div><div class="line">        k++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>, i = low; i &lt;= high; i++, k++) &#123;</div><div class="line">        array[i] = tmpArray[k];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>归并排序的时间复杂度为O(nlogn) </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a&gt;插入排序&lt;/h2&gt;&lt;p&gt;插入排序分很多种，这里主要说明直接插入排序，插入排序很适合已经排好序并且有其他元素要插入指定位置的的元素列。将整个元素列分为
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/Categories/Java/"/>
    
    
      <category term="Java,排序" scheme="http://yoursite.com/Tags/Java-%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java常用排序算法（一）</title>
    <link href="http://yoursite.com/2016/12/17/Java%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2016/12/17/Java常用排序算法/</id>
    <published>2016-12-17T10:06:00.000Z</published>
    <updated>2016-12-17T12:12:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="冒泡法"><a href="#冒泡法" class="headerlink" title="冒泡法"></a>冒泡法</h2><p>冒泡排序相对于其他算法来讲较为简单，很好理解。以升序为例，主要是比较相邻的两个元素，如果第一个比第二个大就对换两个元素的位置。接下来比较下一对相邻的元素，对每一对相邻的元素做重复操作。一次轮寻之后就将元素中最大的元素排在了末尾，接下来比较其他元素（注意，第二次轮寻就没必要再比较最后一个元素了，因为他已经排好了）。继续轮寻重复比较，完成第二次轮寻之后就将第二大的元素排在了倒数第二的位置上，以此类推。重复执行元素个数的次数轮寻之后，得到的就是排好序的元素列。代码如下：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 冒泡法排序&lt;br/&gt;</div><div class="line"> * &lt;p&gt;</div><div class="line"> * &lt;li&gt;比较相邻的元素。如果第一个比第二个大，就交换他们两个。&lt;/li&gt;</div><div class="line"> * &lt;li&gt;对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。&lt;/li&gt;</div><div class="line"> * &lt;li&gt;针对所有的元素重复以上的步骤，除了最后一个。&lt;/li&gt;</div><div class="line"> * &lt;li&gt;持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。&lt;/li&gt;</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> array 需要排序的整型数组</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> temp;</div><div class="line">    <span class="keyword">int</span> endNum = array.length - <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; endNum; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (endNum) - i; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</div><div class="line">                temp = array[j];</div><div class="line">                array[j] = array[j + <span class="number">1</span>];</div><div class="line">                array[j + <span class="number">1</span>] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>冒泡排序是一种稳定排序算法。当两个元素相同时，无论是否相邻，都不会将两个元素兑换，没有这个必要，代码也没有这种实现。只有不同的时候，才会根据是升序还是降序而对调。冒泡排序较为简单，属于入门级别的排序算法。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>冒泡排序的最坏时间复杂度为O(n^2)，最好的时间复杂度O(n)，平均时间复杂度为O(n^2)。  </p>
<h2 id="快速排序法"><a href="#快速排序法" class="headerlink" title="快速排序法"></a>快速排序法</h2><p>快速排序法是对冒泡排序的一种改进。属于较难理解的排序算法。以升序为例，只需要一次轮寻排序，首先找到个基准点，一般是以首元素为基准点。将要排序的数组分为两部分，比基准点小的为一部分，排在基准点的左边；比基准点大的一部分，排在基准点的右边；然后按照此方法，在对两部分分别进行快速排序，整个排序过程可以递归进行。最后得到的数据就是有序数列。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 快速排序&lt;br/&gt;</div><div class="line"> * &lt;ul&gt;</div><div class="line"> * &lt;li&gt;从数列中挑出一个元素，称为“基准”&lt;/li&gt;</div><div class="line"> * &lt;li&gt;重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分割之后，</div><div class="line"> * 该基准是它的最后位置。这个称为分割（partition）操作。&lt;/li&gt;</div><div class="line"> * &lt;li&gt;递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。&lt;/li&gt;</div><div class="line"> * &lt;/ul&gt;</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> array</div><div class="line"> * <span class="doctag">@param</span> start</div><div class="line"> * <span class="doctag">@param</span> end</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (start &lt; end) &#123;</div><div class="line">        <span class="keyword">int</span> base = array[start];</div><div class="line">        <span class="keyword">int</span> temp;</div><div class="line">        <span class="keyword">int</span> i = start;</div><div class="line">        <span class="keyword">int</span> j = end;</div><div class="line"></div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            <span class="keyword">while</span> (array[i] &lt; base &amp;&amp; i &lt; end) &#123;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span> (array[j] &gt; base &amp;&amp; j &gt; start) &#123;</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (i &lt;= j) &#123;</div><div class="line">                temp = array[i];</div><div class="line">                array[i] = array[j];</div><div class="line">                array[j] = temp;</div><div class="line">                i++;</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">while</span> (i &lt;= j);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (start &lt; j) &#123;</div><div class="line">            quickSort(array, start, j);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (end &gt; i) &#123;</div><div class="line">            quickSort(array, i, end);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>快速排序还有很多改进版，比如随机选择基准数，或者在区间内数据较少时直接使用另外的排序算法，以降低递归深度。有兴趣可以继续研究。而且，这个算法在笔试中考的几率非常高，属于必须掌握的一种排序算法。</p>
<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>快速排序的时间复杂度为O(N*logN)  </p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序是一种很简单很直观的排序算法。以升序为例，从待排序的数组中选择出最小的，将他放在首位，再从剩余的数组元素中选择最小的，放在第二位，以此类推不断重复操作。最后的得到的就是排好序的数组。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 选择排序&lt;br/&gt;</div><div class="line"> * &lt;li&gt;在未排序序列中找到最小元素，存放到排序序列的起始位置&lt;/li&gt;</div><div class="line"> * &lt;li&gt;再从剩余未排序元素中继续寻找最小元素，然后放到排序序列第二位置。&lt;/li&gt;</div><div class="line"> * &lt;li&gt;以此类推，直到所有元素均排序完毕。&lt;/li&gt;</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> array</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> temp, length = array.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</div><div class="line">        <span class="keyword">int</span> k = i;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = length - <span class="number">1</span>; j &gt; i; j--) &#123;</div><div class="line">            <span class="keyword">if</span> (array[j] &lt; array[k]) &#123;</div><div class="line">                k = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        temp = array[k];</div><div class="line">        array[k] = array[i];</div><div class="line">        array[i] = temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>选择排序属于不稳定的排序算法。在一趟选择，如果一个元素比当前元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中两个5的相对前后顺序就被破坏了。</p>
<h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>选择排序的时间复杂度与冒泡排序的时间复杂度一样，同为O(n^2)  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;冒泡法&quot;&gt;&lt;a href=&quot;#冒泡法&quot; class=&quot;headerlink&quot; title=&quot;冒泡法&quot;&gt;&lt;/a&gt;冒泡法&lt;/h2&gt;&lt;p&gt;冒泡排序相对于其他算法来讲较为简单，很好理解。以升序为例，主要是比较相邻的两个元素，如果第一个比第二个大就对换两个元素的位置。接下来
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/Categories/Java/"/>
    
    
      <category term="Java,排序" scheme="http://yoursite.com/Tags/Java-%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>String，StringBuffer，StringBuilder性能比较</title>
    <link href="http://yoursite.com/2016/12/10/String%EF%BC%8CStringBuilder%EF%BC%8CStringBuffer%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/"/>
    <id>http://yoursite.com/2016/12/10/String，StringBuilder，StringBuffer性能比较/</id>
    <published>2016-12-10T14:28:00.000Z</published>
    <updated>2016-12-10T14:48:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、HashCode比较"><a href="#一、HashCode比较" class="headerlink" title="一、HashCode比较"></a>一、HashCode比较</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先上段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      String str1 = <span class="string">"win this game"</span>;</div><div class="line">      System.out.println(<span class="string">"str1 的hashCode: "</span> + str1.hashCode());</div><div class="line"></div><div class="line">      str1 = str1 + <span class="string">" and next game"</span>;</div><div class="line">      System.out.println(<span class="string">"str1 的hashCode: "</span> + str1.hashCode());</div><div class="line"></div><div class="line">      StringBuffer sb1 = <span class="keyword">new</span> StringBuffer(<span class="string">"win this game"</span>);</div><div class="line">      System.out.println(<span class="string">"sb1 的hashCode: "</span> + sb1.hashCode());</div><div class="line">      System.out.println(<span class="string">"sb1 的string的hashCode: "</span> + sb1.toString().hashCode());</div><div class="line"></div><div class="line">      StringBuffer sb2 = sb1.append(<span class="string">" and next game"</span>);</div><div class="line">      System.out.println(<span class="string">"sb2 的hashCode: "</span> + sb2.hashCode());</div><div class="line">      sb2.insert(<span class="number">2</span>, <span class="string">"chen"</span>);</div><div class="line">      System.out.println(<span class="string">"sb2 的hashCode: "</span> + sb2.hashCode());</div><div class="line">      System.out.println(<span class="string">"sb2: "</span> + sb2.toString());</div><div class="line"></div><div class="line">      StringBuilder sbd1 = <span class="keyword">new</span> StringBuilder(<span class="string">"win this game"</span>);</div><div class="line">      System.out.println(<span class="string">"sbd1 的hashCode: "</span> + sbd1.hashCode());</div><div class="line">      sbd1.append(<span class="string">" and next game"</span>);</div><div class="line">      System.out.println(<span class="string">"sbd1 的hashCode: "</span> + sbd1.hashCode());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出：<br>str1 的hashCode: 1699949808<br>str1 的hashCode: -313455930<br>sb1 的hashCode: 1555009629<br>sb1 的string的hashCode: 1699949808<br>sb2 的hashCode: 1555009629<br>sb2 的hashCode: 1555009629<br>sb2: wichenn this game and next game<br>sbd1 的hashCode: 41359092<br>sbd1 的hashCode: 41359092</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用<code>System.out.println(obj.hashCode)</code>输出时对象的哈希码；而非内存地址。在java中是不可能获得对象的真正的内存地址的；因为java中堆是由JVM管理的不能直接操作；只能说此时打印出的hash码表示了该对象在java虚拟机中的内存地址；java虚拟机会根据该<code>hashCode</code>最终在真正的堆空间中给该对象分配一个地址；但是该地址不能通过java的API获取；<code>String</code>变量链接新的字符串时会改变<code>hashCode</code>，变量是在JVM中”链接–断开”；<code>StringBuffer</code> 变量链接新的字符串不会改变hashCode，因为变量的堆地址不会变；<code>StringBuilder</code> 变量链接新的字符串不会改变<code>hashCode</code>，因为变量的堆地址不会变；  </p>
<h3 id="二、性能比较"><a href="#二、性能比较" class="headerlink" title="二、性能比较"></a>二、性能比较</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</div><div class="line">        String str = <span class="string">""</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</div><div class="line">            str = str + <span class="string">"i"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">        <span class="keyword">long</span> time1 = end - begin;</div><div class="line">        System.out.println(<span class="string">"1. String + time = "</span> + time1);</div><div class="line"></div><div class="line">        <span class="keyword">long</span> begin2 = System.currentTimeMillis();</div><div class="line">        String str2 = <span class="string">""</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</div><div class="line">            str2 = str2.concat(i + <span class="string">""</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> end2 = System.currentTimeMillis();</div><div class="line">        <span class="keyword">long</span> time2 = end2 - begin2;</div><div class="line">        System.out.println(<span class="string">"2. String concat time = "</span> + time2);</div><div class="line"></div><div class="line">        <span class="keyword">long</span> begin3 = System.currentTimeMillis();</div><div class="line">        StringBuilder str3 = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</div><div class="line">            str3.append(<span class="string">""</span> + i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> end3 = System.currentTimeMillis();</div><div class="line">        <span class="keyword">long</span> time3 = end3 - begin3;</div><div class="line">        System.out.println(<span class="string">"3. StringBuilder append time = "</span> + time3);</div><div class="line"></div><div class="line">        <span class="keyword">long</span> begin4 = System.currentTimeMillis();</div><div class="line">        StringBuffer sf = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</div><div class="line">            sf.append(<span class="string">""</span> + i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> end4 = System.currentTimeMillis();</div><div class="line">        <span class="keyword">long</span> time4 = end4 - begin4;</div><div class="line">        System.out.println(<span class="string">"4. StringBuffer append time = "</span> + time4);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出：  </p>
<ol>
<li>String + time = 93</li>
<li>String concat time = 89</li>
<li>StringBuilder append time = 3</li>
<li>StringBuffer append time = 2</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>String</code>类由于java的共享设计，在修改变量时使其反复改变栈中的对于堆得引用地址，所以性能低；<code>StringBuffer</code> 和 <code>StringBuilder</code> 类设计时改变其值，其堆内存的地址不变，避免了反复修改栈引用的地址，其性能高；其中<code>StringBuilder</code> 是专门类似于<code>StringBuffer</code>类的非线性安全类，即<code>StringBuffer</code>是线性安全的，适合于多线程操作；<code>StringBuilder</code> 是线性不安全类，适合于单线程操作，其性能比<code>StringBuffer</code>略高;</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、HashCode比较&quot;&gt;&lt;a href=&quot;#一、HashCode比较&quot; class=&quot;headerlink&quot; title=&quot;一、HashCode比较&quot;&gt;&lt;/a&gt;一、HashCode比较&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/Categories/Java/"/>
    
    
      <category term="Java,String" scheme="http://yoursite.com/Tags/Java-String/"/>
    
  </entry>
  
  <entry>
    <title>Java反射练习（一）</title>
    <link href="http://yoursite.com/2016/12/06/Java%E5%8F%8D%E5%B0%84%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2016/12/06/Java反射练习（一）/</id>
    <published>2016-12-06T12:06:00.000Z</published>
    <updated>2016-12-06T12:37:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反射基本API"><a href="#反射基本API" class="headerlink" title="反射基本API"></a>反射基本API</h1><h2 id="通过反射打印类的基本信息"><a href="#通过反射打印类的基本信息" class="headerlink" title="通过反射打印类的基本信息"></a>通过反射打印类的基本信息</h2><ol>
<li>获取基本的信息比如类名，不扯别的直接看代码：  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printDetail</span><span class="params">(DemoInterface demo)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"对象名："</span> + demo.getClass().getName());</div><div class="line">      System.out.println(<span class="string">"类型名："</span> + demo.getClass().getTypeName());</div><div class="line">      System.out.println(<span class="string">"规范名称："</span> + demo.getClass().getCanonicalName());</div><div class="line">      System.out.println(<span class="string">"所在包："</span> + demo.getClass().getPackage());</div><div class="line">      System.out.println(<span class="string">"简单名称："</span> + demo.getClass().getSimpleName());</div><div class="line">      List&lt;Class&lt;?&gt;&gt; interfaceList = Arrays.asList(demo.getClass().getInterfaces());</div><div class="line">      <span class="keyword">for</span> (Class&lt;?&gt; inter : interfaceList) &#123;</div><div class="line">          System.out.println(<span class="string">"实现了："</span> + inter.getName() + <span class="string">"接口"</span>);</div><div class="line">          Method[] methods = inter.getMethods();</div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</div><div class="line">              Method method = methods[i];</div><div class="line">              System.out.println(<span class="string">"方法："</span> + method.getName() + <span class="string">"；"</span>);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      Class&lt;?&gt; superClass = demo.getClass().getSuperclass();</div><div class="line">      System.out.println(<span class="string">"父类："</span> + superClass.getName());</div><div class="line">      Field[] fields = demo.getClass().getFields();</div><div class="line">      Field[] declaredFields = demo.getClass().getDeclaredFields();</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</div><div class="line">          fields[i].setAccessible(<span class="keyword">true</span>);</div><div class="line">          System.out.println(fields[i].getName());         <span class="comment">//public 公共可以访问的属性</span></div><div class="line">      &#125;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; declaredFields.length; i++) &#123;</div><div class="line">          System.out.println(declaredFields[i].getName()); <span class="comment">//private protected public属性，但是不包括继承属性</span></div><div class="line">      &#125;</div><div class="line">      Constructor&lt;?&gt; con[] = demo.getClass().getConstructors();</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; con.length; i++) &#123;</div><div class="line">          System.out.println(<span class="string">"构造函数："</span> + con[i]);</div><div class="line">      &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中几个函数有区别，<code>getField</code>是获取默认情况下可以访问到的属性，也就是公共属性<code>public</code>，如果要访问到私有属性<code>private</code>以及保护属性<code>protected</code>，调用<code>getDeclaredFields()</code>方法，但要注意，如果要对值进行修改，对每个field的访问性设为true,<code>field.setAccessible(true)</code>;  </p>
<ol>
<li>获取本类的全部属性，包括权限修饰符和属性类型，上代码：  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAllProperties</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">    Class&lt;?&gt; demo = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        demo = Class.forName(name);</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    System.out.println(<span class="string">"===============本类属性========================"</span>);</div><div class="line">    <span class="comment">// 取得本类的全部属性</span></div><div class="line">    Field[] field = demo.getDeclaredFields();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; field.length; i++) &#123;</div><div class="line">        <span class="comment">// 权限修饰符</span></div><div class="line">        <span class="keyword">int</span> mo = field[i].getModifiers();</div><div class="line">        String priv = Modifier.toString(mo);</div><div class="line">        <span class="comment">// 属性类型</span></div><div class="line">        Class&lt;?&gt; type = field[i].getType();</div><div class="line">        System.out.println(priv + <span class="string">" "</span> + type.getName() + <span class="string">" "</span></div><div class="line">                + field[i].getName() + <span class="string">";"</span>);</div><div class="line">    &#125;</div><div class="line">    System.out.println(<span class="string">"===============实现的接口或者父类，公共可访问的属性========================"</span>);</div><div class="line">    <span class="comment">// 取得实现的接口或者父类的属性</span></div><div class="line">    Field[] filed1 = demo.getFields();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; filed1.length; j++) &#123;</div><div class="line">        <span class="comment">// 权限修饰符</span></div><div class="line">        <span class="keyword">int</span> mo = filed1[j].getModifiers();</div><div class="line">        String priv = Modifier.toString(mo);</div><div class="line">        <span class="comment">// 属性类型</span></div><div class="line">        Class&lt;?&gt; type = filed1[j].getType();</div><div class="line">        System.out.println(priv + <span class="string">" "</span> + type.getName() + <span class="string">" "</span></div><div class="line">                + filed1[j].getName() + <span class="string">";"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>getModifier</code>为获取权限修饰符方法，比如<code>private,public,protected</code>；<code>getType</code>为获取属性的属性类型；  </p>
<h2 id="通过反射调用构造函数"><a href="#通过反射调用构造函数" class="headerlink" title="通过反射调用构造函数"></a>通过反射调用构造函数</h2><ol>
<li>构造函数的获取方式很简单，调用class.getConstructors()方法获取构造函数的数组；然后调用每个constructor的newInstance方法并传入相应的参数即可；上代码：  </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createObjByReflectConstructor</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">       Class&lt;?&gt; demo = <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           demo = Class.forName(name);</div><div class="line">       &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">           e.printStackTrace();</div><div class="line">       &#125;</div><div class="line">       DemoClass demoClass1 = <span class="keyword">null</span>;</div><div class="line">       DemoClass demoClass2 = <span class="keyword">null</span>;</div><div class="line">       DemoClass demoClass3 = <span class="keyword">null</span>;</div><div class="line">       DemoClass demoClass4 = <span class="keyword">null</span>;</div><div class="line">       DemoClass demoClass5 = <span class="keyword">null</span>;</div><div class="line">       Constructor&lt;?&gt; con[] = demo.getConstructors();</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           demoClass1 = (DemoClass) con[<span class="number">0</span>].newInstance();</div><div class="line">           demoClass2 = (DemoClass) con[<span class="number">1</span>].newInstance(<span class="number">1</span>);</div><div class="line">           demoClass4 = (DemoClass) con[<span class="number">2</span>].newInstance(<span class="number">2</span>, <span class="string">"wang"</span>);</div><div class="line">           demoClass3 = (DemoClass) con[<span class="number">3</span>].newInstance(<span class="string">"chen"</span>);</div><div class="line">           demoClass5 = (DemoClass) con[<span class="number">4</span>].newInstance(<span class="number">3</span>, <span class="string">"li"</span>, <span class="string">"win this game"</span>);</div><div class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">           e.printStackTrace();</div><div class="line">       &#125;</div><div class="line">       System.out.println(demoClass1);</div><div class="line">       System.out.println(demoClass2);</div><div class="line">       System.out.println(demoClass3);</div><div class="line">       System.out.println(demoClass4);</div><div class="line">       System.out.println(demoClass5);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>DemoClass</code>类有五个构造函数，所以返回了有五个元素的构造函数的数组，然后实例化。  </p>
<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取方法很简单。<code>class.getMethods()</code>就可以获取方法数组，如果想要获取指定函数，传入方法名：<code>class.getMethods(String methodName)</code>；上代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeMethod</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">      Class&lt;?&gt; demo = <span class="keyword">null</span>;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">          demo = Class.forName(name);</div><div class="line">      &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">          e.printStackTrace();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">          Method method = demo.getMethod(<span class="string">"sayHello"</span>);</div><div class="line">          method.invoke(demo.newInstance());</div><div class="line">          method = demo.getMethod(<span class="string">"add"</span>, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</div><div class="line">          <span class="keyword">double</span> result = (<span class="keyword">double</span>) method.invoke(demo.newInstance(), <span class="number">1</span>, <span class="number">2</span>);</div><div class="line">          System.out.println(<span class="string">"method 返回："</span> + result);</div><div class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">          e.printStackTrace();</div><div class="line">      &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先获取method，<code>demo.getMethod(&quot;add&quot;, int.class, int.class)</code>;,”add”是方法名，第二个和第三个参数是这个方法要传入的参数类型；调用函数，直接执行函数类的调用方法：<code>method.invoke()</code>；第一个参数是要执行此方法的类，注意要实例化；第二个参数和第三个参数就是方法执行所需要的实参；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实例代码链接：[代码] (<a href="https://github.com/ZhuoSir/SharpJava" target="_blank" rel="external">https://github.com/ZhuoSir/SharpJava</a>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天到此为止吧，不过反射的还会有后续的。。。。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;反射基本API&quot;&gt;&lt;a href=&quot;#反射基本API&quot; class=&quot;headerlink&quot; title=&quot;反射基本API&quot;&gt;&lt;/a&gt;反射基本API&lt;/h1&gt;&lt;h2 id=&quot;通过反射打印类的基本信息&quot;&gt;&lt;a href=&quot;#通过反射打印类的基本信息&quot; class=&quot;
    
    </summary>
    
      <category term="Java反射" scheme="http://yoursite.com/Categories/Java%E5%8F%8D%E5%B0%84/"/>
    
    
      <category term="Java,反射" scheme="http://yoursite.com/Tags/Java-%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Servlet文件上传</title>
    <link href="http://yoursite.com/2016/11/14/Servlet%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%EF%BC%88fileupload%E5%BC%80%E6%BA%90%E6%96%B9%E5%BC%8F%EF%BC%89/"/>
    <id>http://yoursite.com/2016/11/14/Servlet文件上传（fileupload开源方式）/</id>
    <published>2016-11-14T14:10:00.000Z</published>
    <updated>2016-12-06T12:11:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Servlet文件上传"><a href="#Servlet文件上传" class="headerlink" title="Servlet文件上传"></a>Servlet文件上传</h1><p>Servlet一般是在表单提交时候，通过Post请求将文件上传到服务器。上传的文件可以使任何文件，包括图片，文档等。这篇博客暂时只介绍通过Apache的开源包commons-fileupload的方式。首先导入两个必须的jar包：commons-fileupload，commons-io。我选用的版本是1.3.2和2.5。  </p>
<h2 id="文件上传表单"><a href="#文件上传表单" class="headerlink" title="文件上传表单"></a>文件上传表单</h2><p>注意:  </p>
<ul>
<li>表单提交的<code>method</code>方法必须是<code>post</code>,不能使用<code>get</code>方法。  </li>
<li>表单<code>enctype</code>的属性设置为<code>multipart/form-data</code>。</li>
<li>上传单个文件，您应该使用单个带有属性 <code>type=&quot;file&quot;</code> 的 <code>&lt;input .../&gt;</code>标签。为了允许多个文件上传，请包含多个 name 属性值不同的 input 标签。输入标签具有不同的名称属性的值。浏览器会为每个 input 标签关联一个浏览按钮。    </li>
</ul>
<pre><code><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"/TomcatTest/UploadServlet"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></div><div class="line">选择一个文件:</div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"uploadFile"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"上传"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure>
</code></pre><p>后端servlet</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@WebServlet</span>(name = <span class="string">"uploadServlet"</span>, urlPatterns = <span class="string">"/servlet/upload.do"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</div><div class="line">   	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionID = <span class="number">1L</span>;</div><div class="line">   	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String UPLOAD_DIRECTORY = <span class="string">"upload"</span>;</div><div class="line">   	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MEMORY_THRESHOLD = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">3</span>;  <span class="comment">// 3MB</span></div><div class="line">   	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_FILE_SIZE = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">40</span>; <span class="comment">// 40MB</span></div><div class="line">   	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_REQUEST_SIZE = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">50</span>; <span class="comment">// 50MB</span></div><div class="line"></div><div class="line">   	<span class="meta">@Override</span></div><div class="line">   	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></div><div class="line">           <span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line">       	doPost(req, resp);</div><div class="line">   	&#125;</div><div class="line"></div><div class="line">   	<span class="meta">@Override</span></div><div class="line">   	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></div><div class="line">   	        <span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line">   	    <span class="comment">//通过commons-fileupload包上传</span></div><div class="line">   	    uploadByCommonsJar(req, resp);</div><div class="line">   	    getServletContext().getRequestDispatcher(<span class="string">"/show.jsp"</span>)</div><div class="line">   	            .forward(req, resp);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">uploadByCommonsJar</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></div><div class="line">       	   	 <span class="keyword">throws</span> IOException &#123;</div><div class="line">       	<span class="keyword">if</span> (!ServletFileUpload.isMultipartContent(req)) &#123;                           <span class="comment">// 检测是否为多媒体上传</span></div><div class="line">           	PrintWriter writer = resp.getWriter();                                  <span class="comment">// 如果不是则停止</span></div><div class="line">           	writer.println(<span class="string">"Error: 表单必须包含 enctype=multipart/form-data"</span>);</div><div class="line">           	writer.flush();</div><div class="line">           	<span class="keyword">return</span>;</div><div class="line">       	&#125;</div><div class="line">       	DiskFileItemFactory factory = <span class="keyword">new</span> DiskFileItemFactory();</div><div class="line">       	factory.setSizeThreshold(MEMORY_THRESHOLD);                                 <span class="comment">// 设置内存临界值 - 超过后将产生临时文件并存储于临时目录中</span></div><div class="line">       	factory.setRepository(<span class="keyword">new</span> File(System.getProperty(<span class="string">"java.io.tmpdir"</span>)));      <span class="comment">// 设置临时存储目录</span></div><div class="line">       	ServletFileUpload upload = <span class="keyword">new</span> ServletFileUpload(factory);</div><div class="line">       	upload.setFileSizeMax(MAX_FILE_SIZE);                                       <span class="comment">// 设置最大文件上传值</span></div><div class="line">       	upload.setSizeMax(MAX_REQUEST_SIZE);                                        <span class="comment">// 设置最大请求值</span></div><div class="line">       	String uploadPath = getServletContext().getRealPath(<span class="string">"./"</span>)                   <span class="comment">// 获取上传路径</span></div><div class="line">          	     + File.separator + UPLOAD_DIRECTORY;</div><div class="line"></div><div class="line">      		File uploadDir = <span class="keyword">new</span> File(uploadPath);</div><div class="line">       	<span class="keyword">if</span> (!uploadDir.exists()) &#123;</div><div class="line">           	uploadDir.mkdirs();</div><div class="line">       	&#125;</div><div class="line"></div><div class="line">       	<span class="keyword">try</span> &#123;</div><div class="line">           	List&lt;FileItem&gt; fileItems = upload.parseRequest(req);                    <span class="comment">// 解析请求的内容提取文件数据</span></div><div class="line">           	<span class="keyword">if</span> (fileItems != <span class="keyword">null</span> &amp;&amp; !fileItems.isEmpty()) &#123;</div><div class="line">               	<span class="keyword">for</span> (FileItem item : fileItems) &#123;</div><div class="line">                   	String fileName = <span class="keyword">new</span> File(item.getName()).getName();</div><div class="line">                   	String filePath = uploadPath + File.separator + fileName;</div><div class="line">                   	File storeFile = <span class="keyword">new</span> File(filePath);</div><div class="line">                   	System.out.println(filePath);</div><div class="line">                   	item.write(storeFile);</div><div class="line">                   	req.setAttribute(<span class="string">"message"</span>, <span class="string">"文件上传成功"</span>);</div><div class="line">         	      	&#125;</div><div class="line">        	   	&#125;</div><div class="line">       	&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">     	      		e.printStackTrace();</div><div class="line">     	      		req.setAttribute(<span class="string">"message"</span>, e.getMessage());</div><div class="line">    	   	&#125;</div><div class="line">   	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>注意：我采用的是servlet3.0的注释方法配置。所以没有在web.xml里进行配置。接着在相应的show.jsp里显示上传成功的结果就可以了。show.jsp略。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Servlet文件上传&quot;&gt;&lt;a href=&quot;#Servlet文件上传&quot; class=&quot;headerlink&quot; title=&quot;Servlet文件上传&quot;&gt;&lt;/a&gt;Servlet文件上传&lt;/h1&gt;&lt;p&gt;Servlet一般是在表单提交时候，通过Post请求将文件上传到服务
    
    </summary>
    
      <category term="Servlet" scheme="http://yoursite.com/Categories/Servlet/"/>
    
    
      <category term="文件上传" scheme="http://yoursite.com/Tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>MarkDown 基本语法学习（第一篇）</title>
    <link href="http://yoursite.com/2016/11/13/MarkDown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E7%AC%AC%E4%B8%80%E7%AF%87%EF%BC%89/"/>
    <id>http://yoursite.com/2016/11/13/MarkDown-基本语法学习（第一篇）/</id>
    <published>2016-11-13T14:32:00.000Z</published>
    <updated>2016-11-13T15:29:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果一段文字被设为标题，只要在段首加上<code>#</code>就可以，例如：  </p>
<pre><code># 一级标题  
## 二级标题
### 三级标题
</code></pre><p>以此类推；</p>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;列表主要分为两种，有序和无序。  </p>
<h2 id="有序"><a href="#有序" class="headerlink" title="有序"></a>有序</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有序只要在前面加上数字即可，例如：  </p>
<pre><code>1. 你好
2. hello
3. 哦哈呦
</code></pre><h2 id="无序"><a href="#无序" class="headerlink" title="无序"></a>无序</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无序列表前面加上<code>*</code>符号就可以了。例如：  </p>
<pre><code>* 1
* 2
* 3
</code></pre><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在文中引用一处文字或者段落，可以在文本前面加上&gt;符号（大于号）。  </p>
<pre><code>&gt; 这里是引用。
</code></pre><p>效果如下</p>
<blockquote>
<p>这里是引用  </p>
</blockquote>
<h1 id="图片和链接"><a href="#图片和链接" class="headerlink" title="图片和链接"></a>图片和链接</h1><h2 id="图片格式"><a href="#图片格式" class="headerlink" title="图片格式"></a>图片格式</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;插入链接和图片的语法类似，区别在一个<code>!</code>号</p>
<pre><code>![](){ImgCap}{/ImgCap} //图片
[]() //链接  
</code></pre><p>例如：  </p>
<pre><code>[baidu]    (http://baidu.com)
![img](http://m2.quanjing.com/2m/fod_liv002/fo-11171537.jpg)
</code></pre><h1 id="粗体与斜体"><a href="#粗体与斜体" class="headerlink" title="粗体与斜体"></a>粗体与斜体</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;粗体和斜体的区别在于<em>符号的数量，粗体用两个 *</em> 号包裹，斜体只需要一个。  </p>
<pre><code>**粗体**
*斜体*
</code></pre><p>效果如下：<br><strong>粗体</strong><br><em>斜体</em></p>
<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表格比较麻烦，就用一个例子来说明吧，直接看例子就明白了。  </p>
<pre><code>| 姓名        | 年龄           | 性别  |
| ---------|:-------------:| -----:|
| 张三      | 22             | 男 |
| 李四      | 22                |   女 |
| 王二麻子   | 22            |    难 |
</code></pre><table>
<thead>
<tr>
<th>姓名</th>
<th style="text-align:center">年龄</th>
<th style="text-align:right">性别</th>
</tr>
</thead>
<tbody>
<tr>
<td>张三</td>
<td style="text-align:center">22</td>
<td style="text-align:right">男</td>
</tr>
<tr>
<td>李四</td>
<td style="text-align:center">22</td>
<td style="text-align:right">女</td>
</tr>
<tr>
<td>王二麻子</td>
<td style="text-align:center">22</td>
<td style="text-align:right">难</td>
</tr>
</tbody>
</table>
<p><code>:</code>符号代表对齐，居左代表左对齐，居右代表右对齐。左竖线一定要对齐。  </p>
<h1 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码框实现起来也很简单。只需要``将代码包裹起来就可以，这个符号一般在键盘ESC下面的那个按键。使用tab键可以进行缩进。  </p>
<h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><p>分割线的语法只需要三个<code>*</code>即可。例如：<code>***</code></p>
<hr>
<h1 id="其他常规"><a href="#其他常规" class="headerlink" title="其他常规"></a>其他常规</h1><p>markdown没有空格语法，一般就是<code>&amp;nbsp;</code>即可。如果想要换行，一般是<code>space + space + enter</code>;  </p>
<p>今天先写到这里吧。see U next time！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;headerlink&quot; title=&quot;标题&quot;&gt;&lt;/a&gt;标题&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果一段文字被设为标题，只要在段首加上&lt;co
    
    </summary>
    
      <category term="MarkDown学习" scheme="http://yoursite.com/Categories/MarkDown%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="MarkDown" scheme="http://yoursite.com/Tags/MarkDown/"/>
    
  </entry>
  
  <entry>
    <title>第一篇博客</title>
    <link href="http://yoursite.com/2016/11/13/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2016/11/13/第一篇博客/</id>
    <published>2016-11-13T04:17:28.000Z</published>
    <updated>2016-11-13T13:05:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;本人第一篇博客，以前一直想写，但是因为懒一直没有动笔。写博客的好处在于总结经验，加深记忆。但是我一直认为自己记忆力超出常人（事实也的确如此），所以很多乱七八糟的都存在脑子里，但是时间久了有个不好的地方，知识点太嘈杂。尤其是软件，必须要形成整个系统知识网络，所以开始写博客。<br>&nbsp;&nbsp;&nbsp;&nbsp;从今天开始，我会将自己的生活感受，工作上获取到的知识，尽量的写入博客里。开源分享，这是入门极客应该做的事儿。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;本人第一篇博客，以前一直想写，但是因为懒一直没有动笔。写博客的好处在于总结经验，加深记忆。但是我一直认为自己记忆力超出常人（事实也的确如此），所以很多乱七八糟的都存在脑子里，但是时间久了有个不好的地方，知识点太嘈杂。尤其是软件
    
    </summary>
    
    
      <category term="闲扯" scheme="http://yoursite.com/Tags/%E9%97%B2%E6%89%AF/"/>
    
  </entry>
  
</feed>
